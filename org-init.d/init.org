# -*- coding: utf-8 -*-

#+TITLE: Emacs の初期設定

#+HTML_HEAD: <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
#+HTML_HEAD: <script src="https://code.jquery.com/jquery-1.11.3.min.js"></script>
#+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="stylesheet.css" />
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="src-highlight-emacs.css" />

#+HTML_DOCTYPE: html5
#+HTML_CONTAINER: section
#+OPTIONS: html5-fancy:t
#+OPTIONS: toc:2 num:nil ^:nil

* はじめに
org-babel を使って org-mode で設定ファイルを記述しています．

1. =~/.emacs.d/init.el= 読み込み
2. =org-babel-load-file= で  =~/.emacs.d/org-init.d/init.org= から
   =~/.emacs.d/org-init/init.el= を生成
3. =~/.emacs.d/org-init/init.el= を読み込み

#+CAPTION: =~/.emacs.d/init.el=
#+INCLUDE: "~/.emacs.d/init.el" src emacs-lisp
* 参考URL
** MELPA でリリース
- [[http://qiita.com/items/0502030e0875b6902fe1][emacsのプラグイン置き場、MELPAに自作の.elを登録する #elisp #Emacs - Qiita]]
ひととおりやり方が書いてある．
** org-babel
org-babel を使って init.el を書く際に参考にしたサイト．
- [[http://www.gfd-dennou.org/member/uwabami/cc-env/EmacsBasic.html][cc-env - Emacs の基本設定]]
- [[http://ameblo.jp/concello/entry-10786074455.html][ORG-Babel + init.el = ??｜くらいまーず はい]]
** Emacs から解像度を調べる
- [[http://d.hatena.ne.jp/zqwell-ss/20091123/1258989596][EmacsのFontがでかい - Secondary Storage]]
** Windowsバイナリ
- [[http://cha.la.coocan.jp/doc/NTEmacs.html#binary][NTEmacs / Emacs for Windows]]
  - 各種画像系のDLLも入っているので、画像表示もできる。ただなぜかSVGだけは表示できない。
  - 日本語IME向けにパッチを当ててあるので、Windows10でもIMEのウィンドウが出る。しかし未確定文字がうまく表示されず、下駄になってしまう。未解決。
- [[https://github.com/chuntaro/NTEmacs64][chuntaro/NTEmacs64]]
  - バージョン24.4からこちらのバイナリを利用中。感謝。IMEパッチを当てていると自動で =w32-ime.el= をロードするので、それでIMEパッチの有無を判定する。
- [[http://emacsbinw64.sourceforge.net/][emacs-w64 | 64-Bit GNU Emacs for MS Windows with optimization]]
  - こちらはSVGのDLLも同梱されていて、さらにWindowsに対する最適化もしているらしい。確かにキビキビ動いてるようにみえる。=w32-ime= がロードされてないからかも？
  - Windows10ではIMEの変換やウィンドウが出ない。
* 最初に必要な設定
#+BEGIN_SRC emacs-lisp +n
;;; -*- coding: utf-8-unix -*-
(eval-when-compile
  (require 'cl))
#+END_SRC
** 一時ファイル置き場
一時ファイルの置き場となるディレクトリを定義する。

#+BEGIN_SRC emacs-lisp +n
(defun my-locate-user-tmp-file (name)
  "Return an absolute path in per-userfile temporary directory."
  (let ((tmp-dir (locate-user-emacs-file "tmp"))) ; create if not exist
    (expand-file-name name tmp-dir)))
#+END_SRC
** ユーティリティ
#+BEGIN_SRC emacs-lisp +n
(defun my-add-to-path (path)
  "Add a PATH to \"PATH\" environment variable and `exec-path'."
  (let* ((env-path (getenv "PATH"))
         (normalized-path (expand-file-name path)))
    (unless (string-match-p (regexp-quote normalized-path) env-path)
      (setenv "PATH" (concat env-path path-separator normalized-path)))
    (add-to-list 'exec-path normalized-path t)
    ))
#+END_SRC
** 起動時間を測定する
- [[http://aikotobaha.blogspot.jp/2010/08/gnupack-ntemacs23-dotemacs.html][OSSはアルミニウムの翼で飛ぶ: gnupack + NTEmacs23 のdot.emacs]]
- [[http://ubulog.blogspot.jp/2009/08/emacs.html][ubulog: Emacsの起動時間を調べる]]
#+BEGIN_SRC emacs-lisp +n
(defvar my-measure-init-time-file (locate-user-emacs-file ".init_time")
  "File name to write out initialization time.")

(defvar my-measure-previous-time before-init-time "Time at previous point.")
(defvar my-measure-current-time before-init-time "Time at current point.")

(defun my-measure-between-time (pre cur)
  "Return time between two points in msec.

PRE time needs to be before CUR time."
  (let* ((most  (- (nth 0 cur) (nth 0 pre)))
         (least (- (nth 1 cur) (nth 1 pre)))
         (msec  (/ (- (nth 2 cur) (nth 2 pre)) 1000)))
    (+ (* 65536 1000 most) (* 1000 least) msec)))

(defun my-measure-message-time (message)
  ""
  (setq my-measure-previous-time my-measure-current-time)
  (setq my-measure-current-time (current-time))
  (let ((between-time (my-measure-between-time my-measure-previous-time
                                               my-measure-current-time)))
    (with-current-buffer (get-buffer-create " *measure time*")
      (insert (format "%d msec. %s\n" between-time message)))))

(defun my-measure-init-time ()
  (let* ((system-time-locale "C")
         (init-time (my-measure-between-time before-init-time after-init-time)))
    (with-temp-buffer
      (when (file-exists-p my-measure-init-time-file)
        (insert-file-contents-literally my-measure-init-time-file)
        (goto-char (point-min)))
      (insert (format "%6d msec elapsed to initialize. " init-time) ; かかった時間
              (car (split-string (emacs-version) "\n")) ; Emacs のバージョンとハードウェアの名前
              (format-time-string " at %Y-%m-%d (%a) %H:%M:%S" after-init-time nil) ; 起動した日時
              (format " on %s@%s\n" user-login-name system-name)) ; ユーザ名とマシン名
      (write-region (point-min) (point-max) my-measure-init-time-file)
      (kill-buffer))))

; より正確を期すため `after-init-hook' 中に `after-init-time' をはかる
(add-hook 'after-init-hook
          '(lambda ()
             (setq after-init-time (current-time))
             (my-measure-message-time "after-init-hook.")
             (my-measure-init-time))
          t)
#+END_SRC
** OSの判別，固有の設定
- [[http://d.hatena.ne.jp/marcy_o/20081208/1228742294][.emacs で OS の判定を関数化しよう - marcy_oの日記]]
#+BEGIN_SRC emacs-lisp +n
(defconst dropbox-directory (expand-file-name "~/Dropbox")) ; 語尾に / を含めるか含めないか悩むな

(defun macp ()
  (eq system-type 'darwin))
(defun linuxp ()
  (eq system-type 'gnu/linux))
(defun bsdp ()
  (eq system-type 'gnu/kfreebsd))
(defun winp ()
  (eq system-type 'windows-nt))
#+END_SRC
** debian-emacs-flavor
なんか最新版をビルドしたやつはこれをつけたほうがいいらしい？これがないと
ispell が動かなかった。ispell に限らんかもしれんが
#+BEGIN_SRC emacs-lisp +n
(setq debian-emacs-flavor 'emacs-snapshot)
#+END_SRC
** ロードパスの追加
- [[http://masutaka.net/chalow/2009-07-05-3.html][Emacs講座 -第6回- load-path / マスタカの ChangeLog メモ]]
#+BEGIN_SRC emacs-lisp +n
;; site-lisp 以下を追加
(let ((dir (locate-user-emacs-file "site-lisp")))
  (dolist (file (directory-files dir))
    (when (and (not (string= file ".."))
               (file-directory-p (concat dir "/" file)))
      (add-to-list 'load-path (concat dir "/" file)))))
#+END_SRC
** Unixツールのパスを追加する
Cygwinが存在する場合のみパスを追加する。Windowsの =PATH= 環境変数にCygwinのパスを追加すると、他ツールと競合する場合があるのでEmacs内で明示的に追加する。
#+BEGIN_SRC emacs-lisp +n
(defvar cygwinp nil "Whether this system has cygwin or not.")
(let* ((choco-dir (getenv "ChocolateyToolsLocation"))
       (git-for-win-dir (expand-file-name "Git"
                                          (or (getenv "ProgramW6432") (getenv "ProgramFiles"))))
       (cmder-dir (expand-file-name "cmder" choco-dir))
       (cygwin-path (expand-file-name "cygwin" choco-dir)))
       (cond ((file-exists-p git-for-win-dir)
         (my-add-to-path (expand-file-name "mingw64/bin" git-for-win-dir))
         (my-add-to-path (expand-file-name "bin" git-for-win-dir))
         (my-add-to-path (expand-file-name "usr/bin" git-for-win-dir)))
        ((file-exists-p cmder-dir)
         (my-add-to-path (expand-file-name "vendor/git-for-windows/mingw32/bin" cmder-dir))
         (my-add-to-path (expand-file-name "vendor/git-for-windows/cmd" cmder-dir))
         (my-add-to-path (expand-file-name "vendor/git-for-windows/usr/bin" cmder-dir)))
        ((file-exists-p cygwin-path)
         (my-add-to-path (expand-file-name "bin" cygwin-path))
         (my-add-to-path (expand-file-name "usr/bin" cygwin-path))
         (setq cygwinp t))
        (t (message "Not found Unix tools"))))
#+END_SRC
* 見た目の設定など
** カーソル色を設定
=set-cursor-color= だと、フレームの背景色がlightとdarkの場合分けができないの
で、cursorフェイスを直接変更する。
#+BEGIN_SRC emacs-lisp +n
(face-spec-set 'cursor
               '((((class color) (background light))
                  :background "magenta")
                 (((class color) (background dark))
                  :background "yellow")))
#+END_SRC
** vc-mode のモードラインを色付け
バージョンコントロールのモードライン表示をもっと主張させるように色付けする．
ファイルを修正した場合は色を変更して自分にプレッシャーをかける．
#+BEGIN_SRC emacs-lisp +n
(defface my-vc-uptodate-face
  '((t (:foreground "black" :background "green"
        :box (:line-width -3 :style released-button))))
  "Face for version control when up-to-date.")

(defface my-vc-modified-face
  '((t (:foreground "white" :background "red"
        :box (:line-width -3 :style released-button))))
  "Face for version control when modified.")

(defadvice vc-default-mode-line-string (after colorize activate)
  "Colorize `vc-mode-line' according to the vcs state."
  (let ((ml-string ad-return-value))
    (setq ad-return-value
          (cond ((string-match "^[[:ascii:]]+-" ml-string)
                 (propertize ml-string 'face 'my-vc-uptodate-face))
                ((string-match "^[[:ascii:]]+[:@!?]" ml-string)
                 (propertize ml-string 'face 'my-vc-modified-face))
                (t ml-string)))))
#+END_SRC
** フォント設定
#+BEGIN_EXAMPLE
(prin1 (font-family-list))
#+END_EXAMPLE
で使えるフォントのファミリー名が見れる．

#+BEGIN_EXAMPLE
(insert (prin1-to-string (x-list-fonts "*")))
#+END_EXAMPLE
にすると XLFD 表現で表示される．

#+BEGIN_SRC emacs-lisp +n
;;; 端末でフォント設定の意味はないので，条件分岐しておこう．
(when window-system
  (defvar my-default-font-size 15 "Default font size")
  (defvar my-default-font nil "Default font family")
  (defvar my-font-alist '(("Ricty" . 15) ("Ricty Diminished" . 15) ("ＭＳ ゴシック" . 12) ("hoge" . 3))
    "Alist of a font family and size")
  (cl-loop for (font . size) in my-font-alist
           when (member font (font-family-list))
           do
           (setq my-default-font font
                 my-default-font-size size)
           until (member font (font-family-list)))
  (defvar my-current-font-size my-default-font-size "Current font size")
  (when my-default-font
    (set-frame-font (format "%s %d" my-default-font my-default-font-size) nil t)
    (set-face-attribute 'fixed-pitch nil :family my-default-font))
  )

;;; list-faces-display 用の文字列
;;; フォント幅テスト用の文字列．|
;;; 1234567890123456789012345678|
(setq list-faces-sample-text
"フォント幅テスト用の文字列．|
1234567890!\"#$%&'()~-^\\@=~`?|")
#+END_SRC
** default-major-mode
該当しない拡張子のメジャーモード。バージョン23.2以前は =default-major-mode=
を利用していたようだが、それ以降は =major-mode= のグローバル値がみられるよう
になったらしい。しかし23.2でも実際は =default-major-mode= が使われるっぽい？
この値を =nil= にしておけば =major-mode= をみてくれるようになった。ちなみに
=major-mode= の初期値は =fundamental-mode= 。
#+BEGIN_SRC emacs-lisp +n
(setq default-major-mode nil)
#+END_SRC
** frame configure
#+BEGIN_SRC emacs-lisp +n
(add-to-list 'default-frame-alist '(reverse . t))
#+END_SRC
*** TODO 起動時に黒背景にする
Emacs起動時に =--reverse-video= (=-r=) オプションを付けなくても黒背景になるよ
うに、 =(reverse . t)= を =deafult-frame-alist= につけてみたが、効果なし。新
しく作成したフレームは黒背景になる。起動時のフレームを黒背景にするには必ずオ
プションが必要？
** キーバインド
#+BEGIN_SRC emacs-lisp +n
(global-set-key (kbd "C-0") 'delete-window)
(global-set-key (kbd "C-1") 'delete-other-windows)
(global-set-key (kbd "C-2") 'split-window-vertically)
(global-set-key (kbd "C-3") 'split-window-horizontally)
(global-set-key (kbd "C-4") 'ctl-x-4-prefix)
(global-set-key (kbd "C-5") 'ctl-x-5-prefix)
(defalias 'ctl-x-r-prefix ctl-x-r-map)
(global-set-key (kbd "S-C-r") 'ctl-x-r-prefix)
(global-set-key (kbd "C-t") 'other-window-or-split)
;(global-set-key (kbd "C-h") 'delete-backward-char)
(global-set-key (kbd "RET") 'newline-and-indent)
(define-key key-translation-map (kbd "C-h") (kbd "DEL"))
(global-set-key (kbd "M-h") 'backward-kill-word)
;(global-set-key (kbd "C-S-k") '(lambda () (interactive) (kill-buffer)))
(global-set-key (kbd "C-M-;") 'comment-or-uncomment-region)
(global-set-key (kbd "H-n") '(lambda (arg) (interactive "p") (scroll-up arg)))
(global-set-key (kbd "H-p") '(lambda (arg) (interactive "p") (scroll-down arg)))
(global-set-key (kbd "H-u")
  '(lambda () (interactive) (scroll-down (/ (window-height) 2))))
(global-set-key (kbd "H-d")
  '(lambda () (interactive) (scroll-up (/ (window-height) 2))))
(if (winp)
    (setq w32-apps-modifier 'hyper      ; apps キーを hyper キーにする
                                        ; nodoka でカタカナひらがなを app にしている前提
          w32-lwindow-modifier 'super)) ; 左Windows キーを super キーにする
(global-set-key (kbd "S-SPC") 'self-insert-command) ; これがないと S-SPC が SPC に translate される

;;; H-数字 を digit-argument にバインド
(global-set-key (kbd "H-0") 'digit-argument)
(global-set-key (kbd "H-1") 'digit-argument)
(global-set-key (kbd "H-2") 'digit-argument)
(global-set-key (kbd "H-3") 'digit-argument)
(global-set-key (kbd "H-4") 'digit-argument)
(global-set-key (kbd "H-5") 'digit-argument)
(global-set-key (kbd "H-6") 'digit-argument)
(global-set-key (kbd "H-7") 'digit-argument)
(global-set-key (kbd "H-8") 'digit-argument)
(global-set-key (kbd "H-9") 'digit-argument)
#+END_SRC
*** C-c (mode-specific-map)
#+BEGIN_SRC emacs-lisp +n
(define-key mode-specific-map (kbd "c") 'compile)      ; C-c c で compile
(define-key mode-specific-map (kbd "s") 'eshell)
(define-key mode-specific-map (kbd "A") 'align-regexp)
#+END_SRC
*** original key map (bind to C-q)
#+BEGIN_SRC emacs-lisp +n
(defvar my-original-map (make-sparse-keymap)
  "My original keymap binded to C-q.")
(defalias 'my-original-prefix my-original-map)
(global-set-key (kbd "C-q") 'my-original-prefix)
(define-key my-original-map (kbd "a") 'toggle-frame-alpha)
(define-key my-original-map (kbd "C-q") 'quoted-insert)
(define-key my-original-map (kbd "C-t") 'toggle-truncate-lines)
(define-key my-original-map (kbd "C-l") (if (commandp 'display-line-numbers-mode)
                                            'display-line-numbers-mode
                                          'linum-mode))
(define-key my-original-map (kbd "C-w") 'delete-trailing-whitespace)
(define-key my-original-map (kbd "DEL") 'horizontal-scroll-bar-mode)
(defun my-revert-buffer-noconfirm ()
  (interactive)
  (revert-buffer nil t t)
  (vc-refresh-state)
  (message (format "Revert %S" (current-buffer))))
(define-key my-original-map (kbd "C-r") 'my-revert-buffer-noconfirm)
(defun my-kill-buffer-and-close-window ()
  (interactive)
  (kill-buffer)
  (delete-window))
(define-key my-original-map (kbd "C-k") 'my-kill-buffer-and-close-window)
#+END_SRC
** emacsclient を使う
#+BEGIN_SRC emacs-lisp +n
(use-package server
  :custom
  (server-auth-dir (my-locate-user-tmp-file "server/") "サーバ認証ファイル置き場")
  :config
  (cond ((not (server-running-p))
         (server-start))
        ((eq (server-running-p) :other)
         (server-start))))
#+END_SRC
** 時間測定ポイント
#+BEGIN_SRC emacs-lisp +n
(my-measure-message-time "Looks and key bind.")
#+END_SRC
* 自作関数
** JSON文字列として正しくエスケープする
#+BEGIN_SRC emacs-lisp +n
(defun my-json-escape ()
  "Escape string as a valid JSON string."
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (while (re-search-forward "\\\\" nil :noerror)
      (replace-match "\\\\" nil t)))
  (save-excursion
    (goto-char (point-min))
    (while (re-search-forward "\"" nil :noerror)
      (replace-match "\\\"" nil t)))
  (save-excursion
    (goto-char (point-min))
    (while (re-search-forward "\n" nil :noerror)
      (replace-match "\\n" nil t)))
  )
#+END_SRC

** shell-sesison-mode でシェルの実行の様子をハイライトする
GitHubとかGitLabだとコードブロックに =shell-session= という言語名をつけるといい感じにシェルでのコマンド実行とその出力をシンタックスハイライトしてくれる。

Emacsにいい感じのハイライトをしてくれるモードがなかったので自作した。

#+BEGIN_SRC emacs-lisp +n
(use-package shell-session-mode :defer t
  :load-path "my-lisp"
  :init
  (with-eval-after-load 'org-src
    ;; "console" を `shell-session-mode' で解釈する
    (add-to-list 'org-src-lang-modes '("console" . shell-session)))
  )
#+END_SRC
** bom-mode でBOMの有無を明示する
BOMの有無を視覚的に明示したかったので自作した。

#+BEGIN_SRC emacs-lisp +n
(use-package bom-mode :defer t
  :load-path "my-lisp"
  :init
  (add-hook 'prog-mode-hook 'bom-mode)
  (add-hook 'text-mode-hook 'bom-mode))
#+END_SRC
** emoji-cheat-sheet++.el
emoji-cheat-sheet-plus はhelmで絵文字を選べて便利だが、絵文字表記（ =:+1:= みたいなの）しか挿入できず、ユニコードの文字として挿入することができない。不便なのでユニコードを挿入する機能を追加する emoji-cheat-sheet++.el を自作した。

#+BEGIN_SRC emacs-lisp +n
(use-package emoji-cheat-sheet++
  :load-path "my-lisp"
  )
#+END_SRC
** 色を前景色、背景色で組み合わせて表示する
コマンドで呼び出すと利用できるすべての色を組み合わせる。引数を指定した場合は、その色の組み合わせを表示する。
#+BEGIN_SRC emacs-lisp +n
(defun list-color-combinations (&optional list)
  "Combine all foreground colors and background colors, and display them."
  (interactive)
  (let* ((buffer-name "*Color Combinations*")
         (text "sample text")
         (colors (or list (defined-colors)))
         (max-width (->> colors
                         (-map #'length)
                         (-max))))
    (with-current-buffer (get-buffer-create buffer-name)
      (setq buffer-read-only nil)
      (erase-buffer)
      (insert (s-pad-right (length text) " " "Text") "\t"
              (s-pad-right max-width " " "Foreground") "\t"
              (s-pad-right max-width " " "Background") "\n")
      (dolist (fg colors)
        (dolist (bg colors)
          (insert (propertize (s-pad-right (length text) " " text) 'face `(:foreground ,fg :background ,bg)) "\t"
                  (s-pad-right max-width " " fg) "\t"
                  (s-pad-right max-width " " bg) "\n")))
      (setq buffer-read-only t)
      (goto-char (point-min)))
    (pop-to-buffer buffer-name)))
#+END_SRC

引数を指定せずに定義済みの色すべての組み合わせを表示すると、60万通りぐらいあるので表示するのにそこそこ時間がかかる。
** モードラインの文字エンコーディング表示を詳細にする
モードラインにはデフォルトで文字コードに応じた表示になるが、文字コードが一文字のアルファベットで表現されていたり、BOMのある無しがわからないものである。

[[https://www.reddit.com/r/emacs/comments/1nihkt/how_to_display_full_charset_name_in_modeline_eg/]]
を参考に自分で実装してみた。

改行文字によって表示される文字列（ニーモニック）は =eol-mnemonic-dos= などのカスタマイズ変数で変更できるので、それを変更するだけにしました。

#+BEGIN_SRC emacs-lisp +n
;; 改行文字のニーモニック設定
(set 'eol-mnemonic-dos "(CRLF)")
(set 'eol-mnemonic-unix "(LF)")
(set 'eol-mnemonic-mac "(CR)")
(set 'eol-mnemonic-undecided "(?)")

;; 文字エンコーディングのニーモニック
(defun my-coding-system-name-mnemonic (coding-system)
  (let* ((base (coding-system-base coding-system))
         (name (symbol-name base)))
    (cond ((string-prefix-p "utf-8" name) "U8")
          ((string-prefix-p "utf-16" name) "U16")
          ((string-prefix-p "utf-7" name) "U7")
          ((string-prefix-p "japanese-shift-jis" name) "SJIS")
          ((string-match "cp\\([0-9]+\\)" name) (match-string 1 name))
          ((string-match "japanese-iso-8bit" name) "EUC")
          (t "???")
          )))

(defun my-coding-system-bom-mnemonic (coding-system)
  (let ((name (symbol-name coding-system)))
    (cond ((string-match "be-with-signature" name) "[BE]")
          ((string-match "le-with-signature" name) "[LE]")
          ((string-match "-with-signature" name) "[BOM]")
          (t ""))))

(defun my-buffer-coding-system-mnemonic ()
  "Return a mnemonic for `buffer-file-coding-system'."
  (let* ((code buffer-file-coding-system)
         (name (my-coding-system-name-mnemonic code))
         (bom (my-coding-system-bom-mnemonic code)))
    (format "%s%s" name bom)))

;; `mode-line-mule-info' の文字エンコーディングのニーモニック部分を差し替える
;; （"%z" の部分を差し替え）
(setq-default mode-line-mule-info
              (cl-substitute '(:eval (my-buffer-coding-system-mnemonic))
                             "%z" mode-line-mule-info :test 'equal))
#+END_SRC

デフォルトのモードライン設定で文字コードに関する表示を担っているのが =mode-line-mule-info=  なので、それを自分で実装したものに置き換えることでモードラインの表示が変わる。

以下のコードは文字エンコーディングに関する関数のテスト。

#+BEGIN_SRC emacs-lisp :tangle no
(defun my-coding-system-test (coding-system)
  (let* ((base (coding-system-base coding-system))
         (type (coding-system-type coding-system))
         (eol (coding-system-eol-type coding-system))
         (eol-mnemonic (coding-system-eol-type-mnemonic coding-system))
         (mnemonic (coding-system-mnemonic coding-system))
         )
    (format "Coding System:%s\nBase:%s\nType:%s\nEOL:%s\nEOL Mnemonic:%s\nMnemonic:%s"
            coding-system base type eol eol-mnemonic mnemonic)))

#+END_SRC

** 管理者権限が必要なファイルを保存する in Windows
=Start-Process= で =xcopy= コマンドを管理者権限で起動するだけです。UACのプロンプトが出るので、「はい」を押せば保存できる。コピーが何かしらの原因で失敗しても検知できないので注意。

#+BEGIN_SRC emacs-lisp +n
(defun uac-save-buffer ()
  "Save a file owned by Administrator in Windows.

When invoke this command, UAC prompt appears.
"
  (interactive)
  (let ((cbuffer (current-buffer))
        (visited-file (buffer-file-name))
        (modp (buffer-modified-p)))
    (if (not (and visited-file modp))
        (message "(No changes need to be saved)")
      (let* ((temp-file (make-temp-file "uac-save-buffer-"))
             ;; Command run in powershell
             (command (format "Start-Process 'xcopy' -Verb runas -Wait -ArgumentList '/Y','%s','%s'"
                              ;; path separator must be a back slash
                              (replace-regexp-in-string "/" "\\\\" temp-file)
                              (replace-regexp-in-string "/" "\\\\" visited-file))))
        (unwind-protect
          (progn
              (write-region nil nil temp-file nil 'nomsg)
              ;; TODO: error handling when copy failed
              (call-process "powershell" nil nil nil
                            "-NoProfile" "-Command" command)
              (set-buffer-modified-p nil)
              (revert-buffer nil t t) ;; reopen file
              )
          (delete-file temp-file))))))
#+END_SRC

=copy= はcmdの組み込みコマンドなので =Start-Process= で呼び出せないことを学んだ。

- [[http://d.hatena.ne.jp/kitokitoki/20110929/p1][<elisp> write-region() で *Messages* やエコーエリアにメッセージを表示させない]]
=write-region= で =Wrote <filename>= とミニバッファに出るの抑制する方法はこちらで学んだ。
** 自作ライブラリをautoloadする
あらかじめ =my-lisp/loaddefs.el= に =;;;###autoload= トークンを抽出している前提です。
#+BEGIN_SRC emacs-lisp +n
(let ((loaddefs (locate-user-emacs-file "my-lisp/my-loaddefs.el")))
  (when (file-exists-p loaddefs)
    (require 'my-loaddefs loaddefs 'noerror)))
#+END_SRC
** uiflow向けのメジャーモード
- [[https://github.com/hirokidaichi/uiflow][uiflow - the simplest way to write down your ui-flow diagram like markdown]]
#+BEGIN_SRC emacs-lisp +n
(use-package uiflow-mode :defer t
  :load-path "my-lisp"
  :config
  (with-eval-after-load 'smartrep
    (smartrep-define-key uiflow-mode-map "C-c"
      '(("C-n" . uiflow-next-token)
        ("C-p" . uiflow-previous-token)
        )))
  )
#+END_SRC
** =fill-column= 付近の句読点の後ろに改行を挿入するコマンド
分かち書きをしない日本語の文章で =fill-paragraph= コマンドを使うと、単語の途中に改行が入ってしまう。なので句読点の後ろに改行を挿入して =fill-column= を超えないようにするコマンドを定義した。

理想的には段落に形態素解析をかけて、単語（or文節）の後ろに改行を入れるようにすればより実用的になるだろう。

句読点を含まない長い行がある場合の考慮などがまだできてない。
#+BEGIN_SRC emacs-lisp +n
(defun fill-paragraph-jp ()
  "Insert a line break at the back of punctuations around `fill-column'.
This leads a line not to exceed `fill-collumn' (for Japanese)"
  (interactive)
  (save-excursion
    (let ((end (progn (forward-paragraph) (point)))
          (beg (progn (backward-paragraph) (point)))
          (punctuations "[、,。．]")
          (previous-column 0))
      (message "%s - %s" beg end)
      (goto-char beg)
      (while (re-search-forward punctuations end t)
        (if (> (current-column) fill-column)
            (save-excursion
              (goto-char previous-column)
              (insert "\n")
              (setq previous-column 0))
          (setq previous-column (match-end 0))))
      )))
#+END_SRC
** =defcustom= で定義した変数一覧
=setq= の代わりに =set-variable= を使うのに参考にする。
#+BEGIN_SRC emacs-lisp +n
(defun list-custom-variables ()
  "List up variables which is defined by `defcustom'."
  (let (symbols)
    (mapatoms
     (lambda (symbol)
       (when (and (boundp symbol)
                  (plist-member (symbol-plist symbol) 'standard-value)
                  (with-current-buffer "init.org"
                    (goto-char (point-min))
                    (re-search-forward (symbol-name symbol) nil t)))
         (add-to-list 'symbols symbol))))
    symbols))
#+END_SRC
** バッファに紐づくファイルパスをコピーする
#+BEGIN_SRC emacs-lisp +n
(defun my-copy-file-path (&optional buffer)
  "Copy a file path associated with BUFFER to `kill-ring'."
  (interactive)
  (let ((path (buffer-file-name buffer)))
    (if (null path)
        (error "Not visit file")
      (kill-new path)
      (message "Copy file path: %s" path))))
#+END_SRC
** カレントバッファに紐づくファイル名を変更するコマンド
#+BEGIN_SRC emacs-lisp +n
(defun rename-current-buffer-file ()
  "Rename the name of a visited file."
  (interactive)
  (let ((oldname (buffer-file-name))
        newname overwritep)
    (unless oldname (error "Not associated with a regular file"))
    (setq newname (read-file-name "Input new file name: "
                                  default-directory nil nil oldname))
    (setq overwritep (and (file-exists-p newname)
                          (or (y-or-n-p (format "%s already exists. Overwrite? " newname))
                              (error "File already exists: %s" newname))))
    (rename-file oldname newname overwritep)
    (set-visited-file-name newname)))
#+END_SRC
** C-aでインデント位置にカーソル移動するアドバイス
IDEでよくあるやつ。
#+BEGIN_SRC emacs-lisp +n
(defadvice move-beginning-of-line (around to-indentation activate)
  "Move to the beginning of non-white space character before bol."
  (if (= (current-column) (current-indentation))
      ad-do-it
    (back-to-indentation)))
#+END_SRC
** 画面のDPIを計算する
#+BEGIN_SRC emacs-lisp +n
(defun dpi (inch &optional width height)
  (interactive "nInput a screen size in inch: \nnInput a pixel width: \nnInput a pixel height: ")
  (let* ((w (or width (display-pixel-width)))
         (h (or height (display-pixel-height)))
         (diago (sqrt (+ (* w w) (* h h))))
         (dpi (/ w (* inch (/ w diago)))))
    (if (called-interactively-p 'interactive)
        (message "%5.2fdpi" dpi)
      dpi)))
#+END_SRC
** カーソル下の文字のエンコード結果を表示する
文字を様々な文字符号化方式でエンコードした結果を表示する。 =describe-char= と同じような使い勝手のつもり。
#+BEGIN_SRC emacs-lisp +n
(defun describe-encoded-char (pos)
  "Describe how the character at POS is encoded by various coding-systems.
If a coding-system can't safely encode the character, display \"?\"."
  (interactive "d")
  (let ((coding-systems '(utf-8 utf-16be shift_jis shift_jis-2004 cp932 iso-2022-jp))
        (label-fmt "%15s: ")
        (char (char-after pos))
        (byte-to-hex (lambda (byte) (format "%02x" byte))))
    (with-help-window (help-buffer)
      (with-current-buffer standard-output
        (insert (concat (format label-fmt "character") (char-to-string char) "\n"))
        (insert (concat (format label-fmt "code point")
                        (format (if (<= char #xffff) "U+%04x" "U+%06x") char) "\n"))
        (cl-loop for coding-system in coding-systems
                 do
                 (let* ((encoded-bytes (encode-coding-char char coding-system))
                        (encoded-hex (if encoded-bytes
                                         (concat "0x"
                                                 (mapconcat byte-to-hex encoded-bytes ""))
                                       "?")))
                   (insert (concat (format label-fmt coding-system) encoded-hex "\n"))))
        ))))
#+END_SRC

実行例
#+BEGIN_SRC text
      character: a
     code point: U+0061
          utf-8: 0x61
       utf-16be: 0x61
      shift_jis: 0x61
          cp932: 0x61
    iso-2022-jp: 0x61
#+END_SRC
#+BEGIN_SRC text
      character: あ
     code point: U+3042
          utf-8: 0xe38182
       utf-16be: 0x3042
      shift_jis: 0x82a0
          cp932: 0x82a0
    iso-2022-jp: 0x1b24422422
#+END_SRC
#+BEGIN_SRC text
      character: ｱ
     code point: U+ff71
          utf-8: 0xefbdb1
       utf-16be: 0xff71
      shift_jis: 0xb1
          cp932: 0xb1
    iso-2022-jp: ?
#+END_SRC
#+BEGIN_SRC text
      character: 亜
     code point: U+4e9c
          utf-8: 0xe4ba9c
       utf-16be: 0x4e9c
      shift_jis: 0x889f
          cp932: 0x889f
    iso-2022-jp: 0x1b24423021
#+END_SRC
#+BEGIN_SRC text
      character: ①
     code point: U+2460
          utf-8: 0xe291a0
       utf-16be: 0x2460
      shift_jis: ?
          cp932: 0x8740
    iso-2022-jp: ?
#+END_SRC
#+CAPTION: サロゲートペア
#+BEGIN_SRC text
      character: 𩸽
     code point: U+029e3d
          utf-8: 0xf0a9b8bd
       utf-16be: 0xd867de3d
      shift_jis: ?
          cp932: ?
    iso-2022-jp: ?
#+END_SRC
** クォートのシングルとダブルを交換する
"'abc'" を '"abc"' に変換するコマンド。" と ' の両方を文字列の境界として使え
る言語向け。
#+BEGIN_SRC emacs-lisp +n
(defun my-exchange-quote (beg end)
  "Exchange single quote and double quote (\" <-> ').
If no region, exchange all quotes in buffer."
  (interactive "r")
  (unless (and beg end)
    (setq beg (point-min) end (point-max)))
  (save-excursion
    (goto-char beg)
    (while (re-search-forward "\"\\|'" end t)
      (replace-match (if (string= (match-string 0) "\"") "'" "\"")))))
#+END_SRC
** javaコマンドオプションをメニュー表示
#+BEGIN_SRC emacs-lisp +n
(use-package java-options :defer t
  :commands java-options
  :load-path "my-lisp"
  )
#+END_SRC
** 関数実行時にライブラリをロードする
既にロードされている関数に対してautoloadはできないので、defadviceで関数実行前
にロードするようにする。
#+BEGIN_SRC emacs-lisp +n
(defmacro add-autoload (function feature)
  (let ((advice-name (intern (concat "autoload-" (symbol-name feature)))))
    `(defadvice ,function (before ,advice-name activate)
       (require (quote ,feature) nil t))))
#+END_SRC
** インデントに空白を使うか使わないか切り替えるマイナーモード
=indent-tabs-mode= は変数しか定義されておらず、切り替えるコマンドがなかったの
でマイナーモードとして定義した。単に =indent-tabs-mode= を切り替えるだけのモー
ドである。
#+BEGIN_SRC emacs-lisp +n
(define-minor-mode indent-tabs-mode "Toggle `indent-tabs-mode'" nil)
#+END_SRC
** Caskと同じライブラリをpackageでインストールする
=~/.emacs.d/Cask= に書かれているライブラリをpackageでインストールする。ただし
バージョン指定などの記法は考慮していない。
#+BEGIN_SRC emacs-lisp +n
(defun package-sync-cask ()
  "Install libraries in \"~/.emacs.d/Cask\"."
  (interactive)
  (with-temp-buffer
    (insert-file-contents-literally (locate-user-emacs-file "Cask"))
    (goto-char (point-min))
    (let (packages)
      (while (re-search-forward "(depends-on \"\\([^\"]+\\)\")" nil t)
        (add-to-list 'packages (intern (match-string 1)) t))
      (when packages
        (package-refresh-contents)
        (mapc 'package-install packages))
      )))
#+END_SRC
** フレームの背景色のlight、darkを切り替え
残念ながら現在のフレームのlight、darkは切り替えられないみたい。このコマンドで
lightとdarkを切り替えた後に、新しくフレームを作成する必要がある。
#+BEGIN_SRC emacs-lisp +n
(defun toggle-frame-background-class ()
  "Toggle a background class (light or dark) of deafult frame."
  (interactive)
  (let ((reverce-cell (assq 'reverse default-frame-alist)))
    (if reverce-cell
        (setcdr reverce-cell (not (cdr reverce-cell)))
      (add-to-list 'default-frame-alist '(reverse . t)))
    (message "Set a backgournd class to \"%s\""
             (if (assoc-default 'reverse default-frame-alist 'eq) "dark" "light"))))
#+END_SRC
** フレーム透明度のトグル
#+BEGIN_SRC emacs-lisp +n
(defvar default-alpha 0.8)
(defun toggle-frame-alpha ()
  "Toggle an alpha in the current frame."
  (interactive)
  (let ((alpha (frame-parameter nil 'alpha)))
    (set-frame-parameter nil 'alpha (if (and alpha (< alpha 1.0)) 1.0 default-alpha))))
#+END_SRC
** ERT関連
Quick JUnitぽく ~C-0~ でテストを走らせるコマンド。現在位置のテスト名を取得する
方法がかなり不完全。
#+BEGIN_SRC emacs-lisp +n
(defun my-ert-run-dwim ()
  (interactive)
  (let (one two)
    (save-excursion
      (ignore-errors (backward-up-list 99))
      (ignore-errors (down-list 1))
      (forward-sexp 1)
      (setq one (intern-soft (thing-at-point 'sexp)))
      (forward-sexp 1)
      (setq two (intern-soft (thing-at-point 'sexp))))
    (if (eq one 'ert-deftest)
        (ert two)
      (ert t))))
(global-set-key (kbd "C-0") 'my-ert-run-dwim)
#+END_SRC
** 行の入れ替え
- [[http://qiita.com/ShingoFukuyama@github/items/fc51a32e84fd84261565][Emacs - 現在行をそのまま上下に連続移動させる - Qiita キータ]]
#+BEGIN_SRC emacs-lisp +n
(defun move-line-down ()
  (interactive)
  (let ((col (current-column)))
    (save-excursion
      (forward-line)
      (transpose-lines 1))
    (forward-line)
    (move-to-column col)))

(defun move-line-up ()
  (interactive)
  (let ((col (current-column)))
    (save-excursion
      (forward-line)
      (transpose-lines -1))
    (move-to-column col)))

(global-set-key (kbd "M-<down>") 'move-line-down)
(global-set-key (kbd "M-<up>") 'move-line-up)
#+END_SRC
** Org-mode の自動プレビュー
#+BEGIN_SRC emacs-lisp +n
(defun org-my-auto-preview ()
  (interactive)
  (when (eq major-mode 'org-mode)
    (org-html-export-to-html)
    (moz-page-reload)))
;(add-hook 'after-save-hook 'org-my-auto-preview)
#+END_SRC
** open-line したあとにインデントするアドバイス
#+BEGIN_SRC emacs-lisp +n
(defadvice open-line (after and-indent (N) activate)
  "Indent after open-line."
  (save-excursion
    (forward-line N)
    (funcall indent-line-function)))
#+END_SRC
** M-r でカーソル移動した時，インデントの先頭の桁にカーソルを移動する
#+BEGIN_SRC emacs-lisp +n
(defadvice move-to-window-line-top-bottom (after back-to-indentation activate)
  "After executing `move-to-window-line-top-bottom', Move point
to the first non-whitespace character on that line."
  (back-to-indentation))
#+END_SRC

** フレーム共通のフォントサイズを対話的に変更するコマンド
text-scale-adjust のパクリ．
#+BEGIN_SRC emacs-lisp +n
(when window-system
  (defun my-resize-frame-font ()
    "対話的にフォントのサイズを変更するコマンド"
    (interactive)
    (let ((ev last-command-event)
          (echo-keystrokes nil)
          (max-size 33)
          (min-size 9))
      (while ev
        (let ((base (event-basic-type ev)))
          (cond ((eq base ?+)
                 (setq my-current-font-size (min (+ my-current-font-size 1) max-size)))
                ((eq base ?-)
                 (setq my-current-font-size (max (- my-current-font-size 1) min-size)))
                ((eq base ?0)
                 (setq my-current-font-size my-default-font-size))
                (t
                 (setq ev nil))))
        (when ev
          (set-frame-font (format "Ricty %d" my-current-font-size) nil t)
          (setq ev (read-event (format "Font size %d: Press +,-,0" my-current-font-size)))))
      (message "Quit")))
  (define-key my-original-map (kbd "C-+") 'my-resize-frame-font)
  (define-key my-original-map (kbd "C--") 'my-resize-frame-font)
  (define-key my-original-map (kbd "C-0") 'my-resize-frame-font)
  )
#+END_SRC
** =org-init.d/init.el= を更新するコマンド
=org-init.d/init.org= を更新したら，明示的に init.el を更新したい時があるので
作った．
#+BEGIN_SRC emacs-lisp +n
(defun my-update-org-init ()
  (interactive)
  (let* ((proc-name "Org Init")
         (emacs-exec (expand-file-name (invocation-name) (invocation-directory)))
         (org-file (expand-file-name "init.org" org-init-directory))
         (init-file (expand-file-name "init.el" org-init-directory))
         (proc (start-process proc-name
                              (get-buffer-create (format "*%s*" proc-name))
                              emacs-exec
                              "--batch" "-l" "org" "--eval"
                              (format "(org-babel-tangle-file \"%s\" \"%s\" \"emacs-lisp\")"
                                      org-file init-file)
                              )))
    (set-process-sentinel proc
                          (lambda (process event)
                            (message "Finish %S" process)))))
#+END_SRC
** 順方向に mark-ring をたどる
`pop-to-mark-command' は逆方向にしか 'mark-ring' をたどれないので，順方向にも
たどれるコマンドを作った．グローバル版もあり．なかなか快適．ただ，"H-O" とい
うキーが押せない．まあグローバルの方はそこまで役に立たんからいいや．ついでに
マークリングの保持数も増やしておいた．
#+BEGIN_SRC emacs-lisp +n
(setq global-mark-ring-max 256)
(setq mark-ring-max 256)

(defun pop-global-mark-reverse ()
  (interactive)
  (setq global-mark-ring (nreverse global-mark-ring))
  (dotimes (i (if (eq last-command 'pop-global-mark) 2 1))
    (pop-global-mark))
  (setq global-mark-ring (nreverse global-mark-ring)))

(defun pop-to-mark-reverse-command ()
  (interactive)
  (if (null (mark t))
      (error "No mark set in this buffer")
    (setq mark-ring (nreverse mark-ring))
    (dotimes (i (if (eq last-command 'pop-to-mark-command) 2 1))
      (pop-mark))
    (goto-char (mark t))
    (setq mark-ring (nreverse mark-ring))))

(global-set-key (kbd "C-S-o") 'pop-global-mark)
(global-set-key (kbd "C-S-i") 'pop-global-mark-reverse)
(global-set-key (kbd "H-o") 'pop-to-mark-command)
(global-set-key (kbd "H-i") 'pop-to-mark-reverse-command)
#+END_SRC
** mecab で段落を形態素解析
#+BEGIN_SRC emacs-lisp +n
(defun mecab-paragraph (start end)
  (interactive "r")
  (let ((str (buffer-substring-no-properties start end)))
    (with-temp-buffer
      (insert str)
      (goto-char (point-min))
      (while (re-search-forward "\n[ \t]*" nil t)
        (replace-match ""))
      (shell-command-on-region (point-min) (point-max) "mecab"))))
#+END_SRC
** 直前のバッファに切り替える
- [[http://d.hatena.ne.jp/rubikitch/20111211/smalldisplay][集中力5倍！小よく大を制するミニマリストEmacs - (rubikitch loves (Emacs Ruby CUI Books))]]
#+BEGIN_SRC emacs-lisp +n
;;; last-buffer
(defvar last-buffer-saved nil)
;; last-bufferで選択しないバッファを設定
(defvar last-buffer-exclude-name-regexp
  (rx (or "*mplayer*" "*Completions*"
          (regexp "^*Org")
          (regexp "^ "))))
(defun record-last-buffer ()
  (when (and ;; (one-window-p)
             (not (eq (window-buffer) (car last-buffer-saved)))
             (not (string-match last-buffer-exclude-name-regexp
                                (buffer-name (window-buffer)))))
    (setq last-buffer-saved
          (cons (window-buffer) (car last-buffer-saved)))))
(add-hook 'window-configuration-change-hook 'record-last-buffer)
(defun switch-to-last-buffer ()
  (interactive)
  (condition-case nil
      (switch-to-buffer (cdr last-buffer-saved))
    (error (switch-to-buffer (other-buffer)))))
(global-set-key (kbd "C-^") 'switch-to-last-buffer)
#+END_SRC
あまりうまく動かない．なぜか *scratch* バッファがラストバッファに記録されてし
まう．
** 空白を削除する `fixup-whitespace' を修正
`delete-indentation' で日本語文字の間にスペースが入るのが嫌だったので修正．
`delete-indentation' を追うと空白の削除は `fixup-whitespace' でやっていた．
前後の文字が日本語文字だった場合，スペースを挿入しないように条件を追加した．
#+BEGIN_SRC emacs-lisp +n
(defun my-fixup-whitespace ()
  "Fixup white space between objects around point.
Leave one space or none, according to the context."
  (interactive "*")
  (save-excursion
    (delete-horizontal-space)
    (if (or (looking-at "^\\|\\s)")
            (save-excursion (forward-char -1)
                            (looking-at "$\\|\\s(\\|\\s'"))
            (and (or (> (preceding-char) 255)
                     (> (following-char) 255))
                 (not (member (preceding-char) (list ?！ ?？))))
            )
        nil
      (insert ?\s))))
(defalias 'fixup-whitespace-original 'fixup-whitespace)
(defalias 'fixup-whitespace 'my-fixup-whitespace)
#+END_SRC

テスト
#+BEGIN_SRC emacs-lisp :tangle no
(ert-deftest test-fixup-whitespace ()
  (let ((fixtures '(("あ" "い" "あい")
                    ("あ" "i"  "あi")
                    ("a"  "い" "aい")
                    ("。" "あ" "。あ")
                    ("あ" "。" "あ。")
                    ("。" "a"  "。a" )
                    ("a"  "。" "a。" )
                    ("？" "あ" "？ あ")
                    ("あ" "？" "あ？")
                    ("？" "a"  "？ a")
                    ("a"  "？" "a？" )
                    ))
        actual)
    (cl-loop for (first second expected) in fixtures
             do
             (with-temp-buffer
               (insert first "\n" second)
               (delete-indentation)
               (setq actual (buffer-string))
               (should (string= actual expected))))))
#+END_SRC
** カーソル位置の行を複製するコマンド
- [[http://d.hatena.ne.jp/syohex/20120325/1332641491][Re: Emacsに現在行や選択範囲を複製する機能を付けたら思いのほか作業効率が上がった - Life is very short]]
カーソル位置の行を複製する．リージョンがあったらその範囲を複製する．最初見た時
は，そんなに役に立たんだろと思ったけど，ためしにつかってみよう．
#+BEGIN_SRC emacs-lisp +n
;; カーソル位置の行を複製するコマンド
(defun my-duplicate-thing (n &optional beg end)
  (interactive "p\nr")
  (let ((pos (- (point-max) (point)))
        str)
    (if mark-active
        nil
      (setq beg (point-at-bol)
            end (point-at-eol)))
    (setq str (buffer-substring-no-properties beg end))
    (if (not (= (progn (goto-char end) (preceding-char)) ?\n))
        (setq str (concat "\n" str)))
    (dotimes (i n)
      (insert str))
    (goto-char (- (point-max) pos))))
(global-set-key (kbd "H-y") 'my-duplicate-thing)
#+END_SRC
** リージョン全体に対する org-edit-src-code
#+BEGIN_SRC emacs-lisp +n
(defvar org-my-edit-src-info-list nil)
(defvar org-my-edit-src-marker nil)
(defvar org-my-edit-src-buffer "*org-my-edit-src*")

(defvar org-my-src-mode-map (make-sparse-keymap))
(define-key org-my-src-mode-map (kbd "C-c '") 'org-my-edit-src-exit)
(define-key org-my-src-mode-map (kbd "C-x C-s") 'org-my-edit-src-save)

(define-minor-mode org-my-src-mode
  ""
  :init-value nil
  :keymap org-my-src-mode-map
  )

(defun org-my-edit-src-block-sep (&optional buffer)
  "Return separator string according to BUFFER."
  (let ((com-str (if buffer (with-temp-buffer buffer comment-start)
                   comment-start)))
    (unless com-str (setq com-str "#"))                ; default separator
    (propertize (format "%s%s%s-------------------------------------------------------------\n"
                        com-str com-str com-str)
                'read-only t 'rear-nonsticky t 'front-sticky t)))

(defun org-my-edit-src-code (&optional beg end)
  ""
  (interactive "r")
  (if (and beg end
           (region-active-p)
           (not org-my-edit-src-info-list))
      (let ((pt (point))
            (org-buf (current-buffer))
            lang block-sep)
        (goto-char beg)
        (setq org-my-edit-src-marker (point-marker))
        ;; get src block
        (while (re-search-forward "#\\+begin_src" end t)
          (forward-line)
          (add-to-list 'org-my-edit-src-info-list
                       (org-edit-src-find-region-and-lang)))
        (setq org-my-edit-src-info-list (nreverse org-my-edit-src-info-list))
        (goto-char pt)
        ;; extract contents of src block and insert them to edit buffer
        (switch-to-buffer-other-window
         (get-buffer-create org-my-edit-src-buffer))
        ;; set major-mode and minor-mode
        (setq lang (or (cdr (assoc (nth 2 (car org-my-edit-src-info-list)) org-src-lang-modes))
                       (nth 2 (car org-my-edit-src-info-list))))
        (funcall (intern (concat lang "-mode")))
        (org-my-src-mode 1)

        (setq block-sep (org-my-edit-src-block-sep))
        (dolist (info org-my-edit-src-info-list)
          (insert
           block-sep
           (with-current-buffer org-buf
             (buffer-substring-no-properties (nth 0 info) (nth 1 info)))
           "\n"))
        (insert block-sep "\n")
        ;; make separator read-only
        ;; (goto-char (point-min))
        ;; (while (re-search-forward block-sep nil t)
        ;;   (put-text-property (match-beginning 0) (match-end 0) 'read-only t))
        (set-buffer-modified-p nil)
        )
    (org-edit-src-code)
    (message "No region")))

(defun org-my-edit-src-exit (&optional context)
  ""
  (interactive)
  (when (and (buffer-modified-p)
             org-my-edit-src-info-list
             org-my-edit-src-marker)
    (let ((org-buf (marker-buffer org-my-edit-src-marker))
          (block-sep (org-my-edit-src-block-sep))
          org-pt block-beg block-end block-str)
      (goto-char (point-min))
      (re-search-forward block-sep nil t)
      (setq org-pt (marker-position org-my-edit-src-marker))
      (dolist (info org-my-edit-src-info-list)
        (setq block-beg (point)
              block-end (progn (re-search-forward block-sep nil t)
                               (match-beginning 0))
              block-str (buffer-substring-no-properties
                         block-beg (match-beginning 0)))
        (with-current-buffer org-buf
          (goto-char org-pt)
          (delete-region (progn
                           (re-search-forward "#\\+begin_src" nil t)
                           (forward-line)
                           (point-at-bol))
                         (progn
                           (re-search-forward "#\\+end_src" nil t)
                           (forward-line 0)
                           (point)))
          (insert block-str)
          (setq org-pt (point))))
      (set-buffer-modified-p nil)
      (with-current-buffer org-buf (save-buffer))))
  (when (not (eq context 'save))
    (kill-buffer (current-buffer))
    (delete-window)
    (goto-char org-my-edit-src-marker)
    (setq org-my-edit-src-info-list nil
          org-my-edit-src-marker nil)))

(defun org-my-edit-src-save ()
  ""
  (interactive)
  (org-my-edit-src-exit 'save))

(with-eval-after-load 'org
  (define-key org-mode-map (kbd "C-c '") 'org-my-edit-src-code))
#+END_SRC
** find-file 時にバッファ名に補助的な文字列を追加する
現在は snippet に関するに [snippet] を付加するのみ．しかし，yasnippet のファイ
ルには拡張子をつけることにしたので，あんまり意味が無いかも．なんか他にも使い道
を探そう．
#+BEGIN_SRC emacs-lisp +n
(defadvice find-file (after find-file-rename activate)
  ;; when open snippet file, append [snippet]
  (when (string-match "/snippets/" (or (buffer-file-name) ""))
    (rename-buffer (concat (buffer-name) " [snippet]")))
  )
#+END_SRC
** 数値をインクリメント，デクリメント
- [[http://d.hatena.ne.jp/gongoZ/20091222/1261454818][カーソルの位置にある数字列をインクリメントする emacs lisp 改修 - 質のないDiary H]]
通常時に使うのに割り当てるキーバインドがあんまりない．それに cua-mode にイン
クリメントする関数があるので，そっちのほうが便利かも．
#+BEGIN_SRC emacs-lisp +n
(defun my-increment-number (num)
  "Replace progression string of the position of the cursor
by string that added NUM.
Interactively, NUM is the prefix arg.

examle:
At the cursor string \"12\"

M-x increment-string-as-number ;; replaced by \"12\"
C-u 10 M-x increment-string-as-number ;; replaced by \"22\"

At the cursor string \"-12\"

M-x increment-string-as-number ;; replaced by \"-12\"
C-u 100 M-x increment-string-as-number ;; replaced by \"88\""
  (interactive "p")
  (let ((col (current-column)))
    (unless (eolp) (goto-char (1+ (point))))
    (skip-chars-backward "-0123456789")
    (if (re-search-forward "-?[0123456789]+" (point-at-eol) t)
        (progn (replace-match
                (number-to-string (+ num (string-to-number (match-string 0)))))
               (goto-char (1- (point))))
      (move-to-column col))))
(defun my-decrement-number (num)
  ""
  (interactive "p")
  (my-increment-number (- num)))

(global-set-key (kbd "H-a") 'my-increment-number)
(global-set-key (kbd "H-x") 'my-decrement-number)
#+END_SRC
** ウィンドウを対話的にリサイズ
- [[http://d.hatena.ne.jp/khiker/20100119/window_resize][Re: 分割したウィンドウの大きさをインタラクティヴに変更する - とりあえず暇だったし何となく始めたブログ]]
#+BEGIN_SRC emacs-lisp +n
(defun my-window-resizer ()
  "Control window size and position."
  (interactive)
  (let ((window-obj (selected-window))
        (current-width (window-width))
        (current-height (window-height))
        (dx (if (= (nth 0 (window-edges)) 0) 1
              -1))
        (dy (if (= (nth 1 (window-edges)) 0) 1
              -1))
        action c)
    (catch 'end-flag
      (while t
        (setq action
              (read-key-sequence-vector (format "size[%dx%d]"
                                                (window-width)
                                                (window-height))))
        (setq c (aref action 0))
        (cond ((= c ?l)
               (enlarge-window-horizontally dx))
              ((= c ?h)
               (shrink-window-horizontally dx))
              ((= c ?j)
               (enlarge-window dy))
              ((= c ?k)
               (shrink-window dy))
              ;; otherwise
              (t
               (let ((last-command-char (aref action 0))
                     (command (key-binding action)))
                 (when command
                   (call-interactively command)))
               (message "Quit")
               (throw 'end-flag t)))))))
#+END_SRC
** emacsclient の focus 制御のため
- [[http://d.hatena.ne.jp/syohex/20110127/1296141148][emacsclientでフォーカスを移す - Life is very short]]
あんまりうまく動いてない気がする．
#+BEGIN_SRC emacs-lisp +n
(when (and (linuxp) (executable-find "emacs_server_start.pl"))
  (defadvice server-start
    (after server-start-after-write-window-id ())
    (call-process "emacs_serverstart.pl"
                  nil nil nil
                  (number-to-string (emacs-pid))
                  (if window-system
                      "x"
                    "nox")))
  (ad-activate 'server-start))
#+END_SRC
** ミニバッファでカーソルの左側の "/" まで文字を削除
1つ上のディレクトリを指定するのに便利．Emacs 以外でも使いたい．
#+BEGIN_SRC emacs-lisp +n
(defun my-minibuffer-delete-parent-directory ()
  "Delete one level of directory path."
  (interactive)
  (let ((current-pt (point)))
    (when (re-search-backward "/[^/]+/?" nil t)
      (forward-char 1)
      (delete-region (point) current-pt))))
(define-key minibuffer-local-map (kbd "M-^") 'my-minibuffer-delete-parent-directory)
#+END_SRC
** モードラインに現在の文字の説明を表示するマイナーモード
- [[https://github.com/kik/sandbox/blob/master/emacs/show-char.el][sandbox/emacs/show-char.el at master · kik/sandbox]]
#+BEGIN_SRC emacs-lisp +n
;; (defun show-current-char ()
;;   (let ((ch (following-char)))
;;     (format " [U+%04X %s] " ch (get-char-code-property ch 'name))))

;; (easy-mmode-define-minor-mode show-char-mode
;;   "Toggle Show char mode."
;;   nil
;;   (:eval (show-current-char)))
#+END_SRC
** ドヤ顔
- [[http://d.hatena.ne.jp/khiker/20100721/doya][Emacsでドヤが夫を簡易的なアニメーションでみたい - とりあえず暇だったし何となく始めたブログ]]
#+BEGIN_SRC emacs-lisp +n
(defun doya-show ()
  (interactive)
  (let ((doya-faces '("                      ＿＿＿  まぁ確かに・・・
                    ／⌒  '' ⌒＼
                  ／（ ● ) (● )＼             Emacsを立ち上げたのはお前
                ／::⌒  ,    ゝ⌒::＼    (⌒)
                |       `ｰ=-'     |    ﾉ~.ﾚ-r┐､
                ＼               ／   ノ  |.| |
.         ,  ⌒ ´  ＼     ￣   ´ !〈￣｀- Lλ_ﾚﾚ
        /    __       ヽ        |  ￣｀ー‐-‐‐´
.      〃 ,. --ミ        ヽ     i   |/ハ ／
      ji／    ￣｀          ヽ  |\n"

                      "                      ＿＿＿
                    ／ノ '' ⌒＼
                  ／（ ● ) (● )＼でも、この画面まで来れたのは俺のおかげ
                ／::⌒   ,   ゝ⌒::＼
                |       ﾄ==ｨ'     |
    _,rｰく´＼  ＼,--､    `ー'    ／
. ,-く ヽ.＼ ヽ Y´  ／   ー    ´ !｀ｰ-､
  {  -!  l _｣_ﾉ‐′/ ヽ            |    ∧
. ヽ  ﾞｰ'´ ヽ    /     ヽ        i  |/ハ
  ｀ゝ、    ﾉ  ノ         ヽ     |\n"


                      "                      ＿＿＿
                    ／ヽ ''ノ＼
                  ／（ ● ) (● )＼
                ／::⌒    ､＿ゝ⌒::＼   (⌒)          だろっ？
                |         -       |   ﾉ ~.ﾚ-r┐､
                ＼               ／  ノ_  |.| |
.         ,  ⌒ ´  ＼     ￣   ´ !〈￣  ｀-Lλ_ﾚﾚ
        /    __       ヽ        |  ￣｀ー‐-‐‐´
.      〃 ,. --ミ        ヽ     i    |/ハ  ／
      ji／    ￣｀          ヽ  |\n"


                      "                                                         ＿＿＿_
      .                                               ／_ノ   ヽ､_＼
                                                  oﾟ(（○)    (（○）)ﾟo   ,. -- ､
                                               ／::::::⌒（__人__）⌒::::::  /      __,＞─ ､
                                               |          |r┬-|        /                  ヽ
                                               |          |  |   |      ｛                      |__
                                               |          |  |   |       ｝   ＼             ,丿  ヽ
    ＿＿＿,.-------､            .         |          |  |   |      /    ､  ｀┬----‐１      }
（⌒        _,.--‐       ｀ヽ        .         |          |  |   |   .／      `￢.|         l      ﾉヽ
  ` ー-ｧ'' / / r'⌒)        ￣￣`ー‐--  ＼         `ー'ｫ  /        ､ !_/.ｌ        l      /   ｝
          ＼＼＼_／     ノ＿＿＿             `''ー          {           ＼         l     /    ,'
              ￣ `（＿,r'             ￣`ー-､        .     ／ ＼          ´｀ヽ.__,ノ    /    ﾉ
                                               ／          ／        ＼         ヽ､＼ __,ノ  ／
                                            ／          ／              ￣ ヽ､_    〉 ,!､__／
                                           /    ＿   く                           ￣
                                         ／ ／    ＼  ＼
                                      ／ ／          ＼  ＼
                  .                ／ ／              ／  ／
                               ／  ／                ゝ、  ヽ
                            ／  ／                       ￣
                         ／    /
                        r＿__ノ\n"



                 "          ／￣￣  ＼
        ／ﾉ(  _ノ   ＼
        |  ⌒(（ ●）（●）             うぜえ！
        .|         （__人__）  /⌒l
         |          ｀ ⌒´ﾉ  |`'''|
        ／ ⌒ヽ         }   |   |                      ＿＿＿_
     ／   へ    ＼     }__/  /                      ／  ─    —＼
  ／  ／  |           ノ    ノ                     ／●））    （（●＼ . ’,  ･   ぐぇあ
( _ ノ       |           ＼´             ＿     ／       （__人__）’,∴＼ ,   ’
             |              ＼＿,, -‐ ''\"   ￣￣ﾞ''—---└'´￣｀ヽ/    >  て
             .|                                                ＿＿ ノ  ／   （
              ヽ                      ＿,, -‐ ''\"￣ヽ､￣  `ー'´   ／   ｒ'\"￣
                 ＼              , '´                   /            .|
                    ＼          (                     /              |
                       ＼        ＼                /\n"

))
        ol)
    (dolist (i doya-faces)
      (setq ol (make-overlay (window-start) (point-max)))
      (setq i (propertize i 'face 'highlight))
      (unwind-protect
          (progn (overlay-put ol 'after-string i)
                 (overlay-put ol 'invisible t)
                 (redisplay)
                 (sleep-for 1.5)
                 (discard-input))
        (delete-overlay ol)))))
;(add-hook 'emacs-startup-hook 'doya-show t)
#+END_SRC
** 対話的にフレームサイズを変えるのだ
やさしいEmacs-Lisp講座 より
#+BEGIN_SRC emacs-lisp +n
(defun my-resize-frame-interactively ()
  "対話的にフレームサイズを変えるのだ"
  (interactive)
  (let (key (width (frame-width)) (height (frame-height)))
    (catch 'quit
      (while t
        (setq key (read-char))
        (cond
         ((eq key ?n) (setq height (1+ height)))
         ((eq key ?p) (setq height (1- height)))
         ((eq key ?f) (setq width (1+ width)))
         ((eq key ?b) (setq width (1- width)))
         (t (throw 'quit t)))
        (modify-frame-parameters
         nil (list (cons 'width width) (cons 'height height)))))
    (message "おちまい")))
#+END_SRC
** 句読点を統一するコマンド
#+BEGIN_SRC emacs-lisp +n
(defun my-replace-touten ()
  "読点を．に統一"
  (interactive)
  (save-excursion
    (replace-string "。" "．" nil (point-min) (point-max))))
(defun my-replace-kuten ()
  "句点を，に統一"
  (interactive)
  (save-excursion
    (replace-string "、" "，" nil (point-min) (point-max))))
#+END_SRC
** other-window を空気を読んで賢くする
Emacs テクニックバイブルより．アスペクト比によってどう分割するかを変更する工
夫なども自分で入れている．
#+BEGIN_SRC emacs-lisp +n
(defun window-toggle-division ()
  "ウィンドウ 2 分割時に、縦分割<->横分割を切り替える"
  (interactive)
  (unless (= (count-windows :ignore-minibuf) 2)
    (error "ウィンドウが 2 分割されていません。"))
  (let* ((edge (window-edges))
         (top-left-p (and (eq (nth 0 edge) 0)
                          (eq (nth 1 edge) 0)))
         (before-height (window-height))
         (other-buf (progn (other-window 1) (window-buffer)))
         (other-pt (point)))
    (delete-window)
    (if (= (window-height) before-height)
        (split-window-vertically)
      (split-window-horizontally))
    (when top-left-p (other-window 1))
    (switch-to-buffer other-buf t)
    (goto-char other-pt)
    (other-window 1)))

(defun other-window-or-split (&optional prefix)
  "Split window if one window exists. Otherwise move a window."
  (interactive "P")
  (when (one-window-p) (split-window-sensibly))
  (cond ((equal prefix '(4)) (other-window -1))
        ((equal prefix '(16)) (window-toggle-division))
        (t (other-window 1))))
#+END_SRC
** 時間測定ポイント
#+BEGIN_SRC emacs-lisp +n
(my-measure-message-time "My original function.")
#+END_SRC
* その他一般的な動作設定
** デフォルトのインデントコマンドを変更
デフォルトのインデントコマンドは =indent-relative= だけど使いにくいので、タブ幅ごとにインデントする =tab-to-tab-stop= に変更する。
#+BEGIN_SRC emacs-lisp +n
(setq-default indent-line-function #'tab-to-tab-stop)
#+END_SRC
** プロセスの文字コードを設定
#+BEGIN_SRC emacs-lisp +n
(cond ((winp)
       (add-to-list 'process-coding-system-alist '("java" . cp932-dos))
       (setq file-name-coding-system 'cp932)
       ))
#+END_SRC
** ファイル末尾の自動改行挿入をしない
#+BEGIN_SRC emacs-lisp +n
(setq require-final-newline nil)
(setq mode-require-final-newline nil)
#+END_SRC
** 自動ウィンドウ分割の方向
=split-width-threshold= と =split-height-threshold= で自動ウィンドウ分割され
るときに、上下分割するか、左右分割するかを調節できる。
=split-width-threshold= はデフォルトで160だが、1600x900のモニタだとぎりぎり
160より小さいので、150に変更する。
#+BEGIN_SRC emacs-lisp +n
(setq split-width-threshold 150)
#+END_SRC
** ファイルの削除はごみ箱を使う
完全にファイルが消えるのは心臓に悪いので設定しておく．
#+BEGIN_SRC emacs-lisp +n
(setq delete-by-moving-to-trash t)
#+END_SRC
** Emacs24 で動作が重くなったのを改善
どうも右から左に書く言語のための設定のようだが，デフォルトでは無効にしたほう
が動作が軽快なようですね．
#+BEGIN_SRC emacs-lisp +n
(setq-default bidi-display-reordering nil
              bidi-paragraph-direction (quote left-to-right))
#+END_SRC
** タイムスタンプ
ファイルに Time-stamp: <> があれば自動的にタイムスタンプを追加する
#+BEGIN_SRC emacs-lisp +n
(add-to-list 'write-file-hooks 'time-stamp)
(setq time-stamp-format "%:y-%02m-%02d %02H:%02M:%02S")
#+END_SRC
** 右クリックメニューを有効にする
- [[http://blogs.yahoo.co.jp/rakuten200802/31224692.html][Windows環境でEmacsを活用しよう　Part2　～.emacsのいくつかの設定～ - Webメディア開発日記 - Yahoo!ブログ]]
意外と右クリックメニューは使える気がする．
#+BEGIN_SRC emacs-lisp +n
(when window-system
  ;; 右ボタンの割り当て(押しながらの操作)をはずす。
  (global-unset-key [down-mouse-3])
  ;; マウスの右クリックメニューを出す(押して、離したときにだけメニューが出る)
  (defun bingalls-edit-menu (event)
    (interactive "e")
    (popup-menu menu-bar-edit-menu))
  (global-set-key [mouse-3] 'bingalls-edit-menu))
#+END_SRC
** モードラインのモード表示を変更する
*** マイナーモード
#+BEGIN_SRC emacs-lisp +n
(loop for (mode file lighter)
      in '((isearch-mode "isearch" "")
           (ibus-mode "ibus" "")
           (undo-tree-mode "undo-tree" " Utree"))
      do  (eval-after-load file
            `(setcar (cdr (assq (quote ,mode) minor-mode-alist)) ,lighter)))
#+END_SRC
*** メジャーモード
#+BEGIN_SRC emacs-lisp +n
(dolist (elm '((emacs-lisp-mode . "Elisp")
               (lisp-interaction-mode . "LispInt")))
  (add-hook (intern (concat (symbol-name (car elm)) "-hook"))
            `(lambda () (setq mode-name ,(cdr elm)))))
#+END_SRC
** スクロール時にカーソルを移動しない
=scroll-preserve-screen-position= でスクロール時のカーソル位置を調節できる。
nil がデフォルトの動作。t だとカーソルが画面外に出るようなスクロール（スクロー
ル量が多い）の時にはカーソルが移動しなくなる。nil でも t でもない場合は常に移
動しなくなる。
#+BEGIN_SRC emacs-lisp +n
(setq scroll-preserve-screen-position :always)
#+END_SRC
** C-k で改行も切り取る
kill whole line by `kill-line'
#+BEGIN_SRC emacs-lisp +n
(setq kill-whole-line t)
#+END_SRC
** *message* バッファの行数設定
max length of log
#+BEGIN_SRC emacs-lisp +n
(setq messages-buffer-max-lines 10000)
#+END_SRC
** リージョン選択時に文字入力するとリージョンを削除する
- [[http://d.hatena.ne.jp/web7_77/20110705/1309885434][Emacsでリージョンを上書き入力できるようにする - Web7.77]]
範囲選択時に文字入力や文字削除した際の動作が一般的なエディタと同じ動作になる。
BackSpaceやC-hでkill-ringに入れずに削除できるのが地味に便利。
#+BEGIN_SRC emacs-lisp +n
(delete-selection-mode t)
#+END_SRC
** デフォルトの折り返し量
Org-mode のデフォルトと揃えた．
#+BEGIN_SRC emacs-lisp +n
(setq default-fill-column 77)
#+END_SRC
** バックアップファイルを一箇所にまとめる
- [[http://marigold.sakura.ne.jp/devel/emacs/backup_file/index.html][バックアップファイルについての設定]]
#+BEGIN_SRC emacs-lisp +n
(setq make-backup-files t)
(setq backup-directory (expand-file-name "~/.bak"))
(unless (file-directory-p backup-directory)
  (make-directory-internal backup-directory))
(if (and (boundp 'backup-directory)
         (not (fboundp 'make-backup-file-name-original)))
    (progn
      (fset 'make-backup-file-name-original
            (symbol-function 'make-backup-file-name))
      (defun make-backup-file-name (filename)
        (if (and (file-exists-p (expand-file-name backup-directory))
                 (file-directory-p (expand-file-name backup-directory)))
            (concat (expand-file-name backup-directory)
                    "/" (file-name-nondirectory filename))
          (make-backup-file-name-original filename)))))
#+END_SRC
** ロケール設定
#+BEGIN_SRC emacs-lisp +n
(setq system-time-locale "C")
#+END_SRC
** デバッグ
普段はコメントアウトしておいて，必要なときに有効にする．
#+BEGIN_SRC emacs-lisp +n
;;; backtrace when debugging
;(setq debug-on-error t)
;(setq debug-on-error nil)
#+END_SRC
** max-specpdl-size
#+BEGIN_SRC emacs-lisp +n
(setq max-specpdl-size 6000)
#+END_SRC
** 初期作業ディレクトリを HOME にする
#+BEGIN_SRC emacs-lisp +n
;;; 2011-04-15 (Fri)
(when (or (null (getenv "PWD"))
          (equal (getenv "PWD") "/"))
  (cd "~/"))
#+END_SRC
** フレームのタイトル
"ファイル名 - emacs@ホスト名" にした．
- [[http://cas.eedept.kobe-u.ac.jp/~arai/PCQA/3.7.html][新居良祐サポートページ － パソコン Q&A 3.7 Emacs のタイトルバーにファイル名を表示させたい]]
#+BEGIN_SRC emacs-lisp +n
(setq frame-title-format '("%b - " invocation-name "@" system-name))
#+END_SRC
** null-device
#+BEGIN_SRC emacs-lisp +n
(setq-default null-device (if (winp) "nul" "/dev/null"))
#+END_SRC
** IME
*** Windows
#+BEGIN_SRC emacs-lisp +n
(when (and (winp) (featurep 'w32-ime))
  (setq default-input-method "W32-IME")         ;標準IMEの設定
  (w32-ime-initialize)                 ;IMEの初期化
  (setq w32-ime-buffer-switch-p t)     ;バッファ切り替え時にIME状態を引き継がない
  ;; IME の on/off を表示
  (setq-default w32-ime-mode-line-state-indicator "[--]")
  (setq w32-ime-mode-line-state-indicator "[--]")
  (setq w32-ime-mode-line-state-indicator-list
        '("[--]" "[あ]" "[--]"))
  ;; IME ON/OFF時のカーソルカラー
  ;; ※input-method-activate-hook, input-method-inactivate-hook じゃない方がいい感じになる
  (add-hook 'w32-ime-on-hook
            (function (lambda ()
                        (set-cursor-color "green"))))
  (add-hook 'w32-ime-off-hook
            (function (lambda ()
                        (set-cursor-color "yellow"))))
  ;; key-chord が無効になってしまうのは以下で解決できた
  ;; http://d.hatena.ne.jp/grandVin/20080917/1221653750
  (defadvice toggle-input-method (around toggle-input-method-around activate)
    (let ((input-method-function-save input-method-function))
      ad-do-it
      (setq input-method-function input-method-function-save)))
  ;; isearch で IME を off にする
  (wrap-function-to-control-ime 'isearch-forward t nil)
  (wrap-function-to-control-ime 'isearch-forward-regexp t nil)
  (wrap-function-to-control-ime 'isearch-backward t nil)
  (wrap-function-to-control-ime 'isearch-backward-regexp t nil)
)
#+END_SRC
** EOF 以降の空行を表示
#+BEGIN_SRC emacs-lisp +n
(setq-default indicate-empty-lines t)
#+END_SRC
** eval したとき結果が長くても折りたたまない
#+BEGIN_SRC emacs-lisp +n
(setq eval-expression-print-level nil
      eval-expression-print-length nil
      eval-expression-debug-on-error nil)
#+END_SRC
** proxy
#+BEGIN_SRC emacs-lisp +n
;(setq url-proxy-services '(("http" . "localhost:1080")))
#+END_SRC
** *scratch* バッファを消さない
#+BEGIN_SRC emacs-lisp +n
;;; 2011-01-05 (Wed)
(defun my-make-scratch (&optional arg)
  (interactive)
  (progn
    ;; "*scratch*" を作成して buffer-list に放り込む
    (set-buffer (get-buffer-create "*scratch*"))
    (funcall initial-major-mode)
    (erase-buffer)
    (when (and initial-scratch-message (not inhibit-startup-message))
      (insert initial-scratch-message))
    (or arg (progn (setq arg 0)
                   (switch-to-buffer "*scratch*")))
    (cond ((= arg 0) (message "*scratch* is cleared up."))
          ((= arg 1) (message "another *scratch* is created")))))

(add-hook 'kill-buffer-query-functions
          ;; *scratch* バッファで kill-buffer したら内容を消去するだけにする
          (lambda ()
            (if (string= "*scratch*" (buffer-name))
                (progn (my-make-scratch 0) nil)
              t)))

(add-hook 'after-save-hook
          ;; *scratch* バッファの内容を保存したら *scratch* バッファを新しく作る
          (lambda ()
            (unless (member (get-buffer "*scratch*") (buffer-list))
              (my-make-scratch 1))))
#+END_SRC
** `kill-ring' とクリップボードを同期
#+BEGIN_SRC emacs-lisp +n
(setq x-select-enable-clipboard t)
#+END_SRC
** ビープ音を消す
#+BEGIN_SRC emacs-lisp +n
;(setq visible-bell t)    ; ビープ音の変わりに画面がフラッシュ
(setq ring-bell-function 'ignore)    ; エラー時に何も起こらなくなる

(defun my-beep-force ()
  (let ((visible-bell nil)
        (ring-bell-function nil))
    (ding)))
#+END_SRC
** ツールバー
非表示にする．
#+BEGIN_SRC emacs-lisp +n
(tool-bar-mode 0)
#+END_SRC
** メニューバー
表示させる．
#+BEGIN_SRC emacs-lisp +n
(menu-bar-mode 1)
#+END_SRC
** マウスカーソル除去
カーソルとマウスカーソルが近づいたら移動させる．
#+BEGIN_SRC emacs-lisp +n
(mouse-avoidance-mode 'jump)
#+END_SRC
** 直感ウィンドウ移動
shift+カーソルキー でウィンドウを移動する．
#+BEGIN_SRC emacs-lisp +n
(windmove-default-keybindings)
#+END_SRC
** 対応する括弧を光らせる
#+BEGIN_SRC emacs-lisp +n
(show-paren-mode 1)
#+END_SRC
** 行の折り返し設定
#+BEGIN_SRC emacs-lisp +n
;(setq truncate-lines t)
(setq truncate-partial-width-windows nil) ; これは分割されたウィンドウで折り返すか否かを制御する
#+END_SRC
** 最大限色分けする
#+BEGIN_SRC emacs-lisp +n
(setq font-lock-maximum-decoration t)
#+END_SRC
** 起動時の画面を非表示
#+BEGIN_SRC emacs-lisp +n
(setq inhibit-startup-message t)
#+END_SRC
** モードラインに行，列番号を表示する
#+BEGIN_SRC emacs-lisp +n
(line-number-mode t)
(column-number-mode t)
#+END_SRC
** スクリプトに実行権限付与
保存時にファイルが #! で始まっていればスクリプトとみなして実行権限を与える
#+BEGIN_SRC emacs-lisp +n
(add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)
#+END_SRC
** 時間設定
#+BEGIN_SRC emacs-lisp +n
;; 標準的なやつ
;(setq display-time-day-and-date nil)
;(setq display-time-24hr-format nil)
;; 日付時刻表示をカスタマイズ
(setq display-time-string-forms
      '((format-time-string "%Y-%m-%d (%a) %H:%M")))
(display-time-mode t)
#+END_SRC
** font-lock
#+BEGIN_SRC emacs-lisp +n
(when (fboundp 'global-font-lock-mode) (global-font-lock-mode t))
#+END_SRC
** リージョンをハイライトする
#+BEGIN_SRC emacs-lisp +n
(transient-mark-mode t)
#+END_SRC
** hide inputting password
#+BEGIN_SRC emacs-lisp +n
(add-hook 'comint-output-filter-functions 'comint-watch-for-password-prompt)
#+END_SRC
** インデントにタブを使わない設定
#+BEGIN_SRC emacs-lisp +n
(setq-default indent-tabs-mode nil)
#+END_SRC
** タブ幅を設定
#+BEGIN_SRC emacs-lisp +n
(setq-default tab-width 4)
#+END_SRC
** isearch
#+BEGIN_SRC emacs-lisp +n
;(define-key isearch-mode-map (kbd "C-h") 'isearch-delete-char) ; isearch中の検索語の文字削除
(define-key isearch-mode-map (kbd "M-@") 'isearch-yank-word)   ; C-w と同じ働き
#+END_SRC
*** リージョン選択時に isearch すると，リージョンで isearch する
- [[http://dev.ariel-networks.com/articles/emacs/part5/][リージョン選択(松山智大) — ありえるえりあ]]
#+BEGIN_SRC emacs-lisp +n
(defadvice isearch-mode (around isearch-mode-default-string
                                (forward &optional regexp op-fun recursive-edit word-p) activate)
  (if (and transient-mark-mode mark-active (not (eq (mark) (point))))
      (progn
        (isearch-update-ring (buffer-substring-no-properties (region-beginning) (region-end)))
        (deactivate-mark)
        ad-do-it)
        ;; (if (not forward)
        ;;     (isearch-repeat-backward)
        ;;   (goto-char (mark))
        ;;   (isearch-repeat-forward)))
    ad-do-it))
#+END_SRC
** 名前，メールの設定
#+BEGIN_SRC emacs-lisp +n
(setq user-full-name "Tsunenobu Kai")
(setq user-mail-address "kai2nenobu@gmail.com")
#+END_SRC
** スクロールバー
やっぱり非表示に変更．`scroll-bar-mode' を関数として使えば，全フレームに対し
て設定が反映されるようだ． =-nw= なEmacsだと =scroll-bar= ライブラリが自動で
ロードさないので、 =windows-system= で条件分岐が必要。
#+BEGIN_SRC emacs-lisp +n
(use-package scroll-bar
  :ensure nil
  :if window-system
  :config
  (scroll-bar-mode -1)
  (horizontal-scroll-bar-mode -1)
  )
#+END_SRC
** 時間測定ポイント
#+BEGIN_SRC emacs-lisp +n
(my-measure-message-time "Customize variable.")
#+END_SRC
* 標準ライブラリ
** startup.el
起動時に自動で読み込まれるelisp？

#+BEGIN_SRC emacs-lisp +n
(use-package startup :defer t
  :ensure nil
  :custom
  (auto-save-list-file-prefix (my-locate-user-tmp-file "auto-save-list.saves-")
                              "自動保存ファイル情報を保存する場所")
  )
#+END_SRC
** abbrev.el
略語展開機能。

#+BEGIN_SRC emacs-lisp +n
(use-package abbrev
  :ensure nil
  :custom
  (abbrev-file-name (my-locate-user-tmp-file "abbrev_defs")
                    "略語を記録したファイル置き場"))
#+END_SRC
** url.el
HTTPアクセス機能。

#+BEGIN_SRC emacs-lisp +n
(use-package url
  :ensure nil
  :custom
  (url-configuration-directory (my-locate-user-tmp-file "url/")))
#+END_SRC
** browse-url
Emacsとブラウザ連携のためのelisp。

#+BEGIN_SRC emacs-lisp +n
(use-package browse-url :defer t
  :ensure nil  ; built-in
  :config
  ;; My functions to open in IE
  (defvar my-browse-url-ie-program "iexplore.exe")
  (defvar my-browse-url-ie-arguments nil)
  (defun my-browse-url-ie (url &optional new-window)
    "Vist URL in IE. NEW-WINDOW is ignored."
    (interactive (browse-url-interactive-arg "URL: "))
    (setq url (browse-url-encode-url url))
    (let* ((process-environment (browse-url-process-environment)))
      (apply 'start-process
             (concat "IE " url) nil
             my-browse-url-ie-program
             (append
              my-browse-url-ie-arguments
              (list url)))))
  ;; Command to switch a browser
  (defun my-switch-browser ()
    "Switch a browser to open a url from Emacs."
    (interactive)
    (let* ((browser-alist '(("default" . browse-url-default-browser)
                            ("Firefox" . browse-url-firefox)
                            ("Chrome" . browse-url-chrome)
                            ("IE" . my-browse-url-ie)
                            ("W3" . browse-url-w3)))
           (browser (completing-read "Select a browser: "
                                     (mapcar #'car browser-alist)
                                     nil t)))
      (if browser
          (progn
            (message "Use %s browser in Emacs!" browser)
            (set 'browse-url-browser-function (assoc-default browser browser-alist)))
        (message "Nothing to do"))))
  ;; Search browser programs in Windows
  (let* ((pfs (list (getenv "PROGRAMFILES") (getenv "PROGRAMFILES(x86)")))
         (firefox (cl-loop for location
                           in (mapcar (lambda (it) (expand-file-name "Mozilla Firefox/firefox.exe" it))
                                      pfs)
                           until (file-exists-p location)
                           finally return location))
         (chrome (cl-loop for location
                          in (mapcar (lambda (it) (expand-file-name "Google/Chrome/Application/chrome.exe" it)) pfs)
                          until (file-exists-p location)
                          finally return location))
         (ie (cl-loop for location
                      in (mapcar (lambda (it) (expand-file-name "Internet Explorer/iexplore.exe" it))
                                 pfs)
                      until (file-exists-p location)
                      finally return location)))
    (when firefox
      (message "Use Firefox at %s" firefox)
      (set 'browse-url-firefox-program firefox))
    (when chrome
      (message "Use Chrome at %s" chrome)
      (set 'browse-url-chrome-program chrome))
    (when ie
      (message "Use Internet Explorer at %s" ie)
      (set 'my-browse-url-ie-program ie)))
  )
#+END_SRC
** bat-mode
バッチファイル編集用のメジャーモード。[2016-11-17 Thu]時点でいつの間にか標準ライブラリに含まれていた。
#+BEGIN_SRC emacs-lisp +n
(use-package bat-mode :defer t
  :mode (("\\.[bB][aA][tT]$" . bat-mode)
         ("CONFIG\\."        . bat-mode)
         ("AUTOEXEC\\."      . bat-mode))
  :config
  (when (winp)
    (add-hook 'bat-mode-hook
              (lambda ()
                (set (make-local-variable 'shell-file-name)
                     (expand-file-name "cmdproxy.exe" exec-directory)))))
  )
#+END_SRC
** js-mode
#+BEGIN_SRC emacs-lisp +n
(use-package js :defer t
  :config
  (set-variable 'js-indent-level 2))
#+END_SRC
** sql
#+BEGIN_SRC emacs-lisp +n
(use-package sql :defer t
  :config
  (use-package sql-indent)
  )
#+END_SRC
** electric-pair-mode
引用符や括弧のようなペアになっている2つの文字を自動挿入するライブラリ。
#+BEGIN_SRC emacs-lisp +n
(use-package elec-pair
  :config
  (electric-pair-mode 1) ; `electric-pair-mode' is a global minor mode
  )
#+END_SRC
** lisp-mode
#+BEGIN_SRC emacs-lisp +n
(use-package lisp-mode :defer t
  :ensure nil
  :config
  (defun emacs-lisp-configuration ()
     (setq tab-width 8))
  (add-hook 'emacs-lisp-mode-hook #'emacs-lisp-configuration))
#+END_SRC
** ediff
ファイルのマージをサポートするライブラリ。もちろん3-wayマージもできる。

#+BEGIN_SRC emacs-lisp +n
(use-package ediff :defer t
  :custom
  (ediff-window-setup-function 'ediff-setup-windows-plain
                               "コントロールパネルを同一フレームに表示する")
  (ediff-split-window-function 'split-window-horizontally
                               "Diffウィンドウを左右に分割する")
  )
#+END_SRC

+elscreenとの共存が難しそう。+ よく試してみると ~elscreen~ と共存できないというわけでもないらしい。 ~elscreen~ を有効にしても ~ediff~ による3-wayマージの画面にできたし、コントロールパネルでの操作もできた。 ~init.el~ のどこかの設定と競合してそうな感じだ。

ひとまずコントロールパネルを同一フレームに表示すれば、現状のままでも動作するので気にしないことにする。
** dired.el
#+BEGIN_SRC emacs-lisp +n
(use-package dired :defer t
  :ensure nil
  :config
  (bind-key "M-p" nil dired-mode-map)
  (bind-key "M-n" nil dired-mode-map)

;; Automatically guess a target directory
(setq dired-dwim-target t)

(defun dired-toggle-dwim-target ()
  "Toggle `dired-dwim-target'"
  (interactive)
  (setq dired-dwim-target (not dired-dwim-target))
  (message (concat (if dired-dwim-target "Enable" "Disable")
                   " "
                   (symbol-name 'dired-dwim-target))))
#+END_SRC
*** dired+.el
dired.el, dired-x.el, dired-aux.el の拡張
#+BEGIN_SRC emacs-lisp +n
(use-package dired+ :defer t
  :quelpa (dired+ :fetcher github :repo "emacsmirror/dired-plus")
  :ensure nil
  :init
  (with-eval-after-load 'dired
    (require 'dired+ nil t))
  :config
  (bind-key "M-p" nil dired-mode-map)
  (bind-key "M-n" nil dired-mode-map)
  )

(setq ls-lisp-dirs-first t)
(setq ls-lisp-ignore-case t)
(setq dired-listing-switches "-lAh")
#+END_SRC
*** wdired.el
dired でファイルのリネームをする．最近は =dired-mode= で
=dired-toggle-read-only (C-x C-q)= でwdired-modeが有効になるようである。
#+BEGIN_SRC emacs-lisp +n
(use-package wdired :defer t
  :config
  (define-key  wdired-mode-map "M-m" '(lambda () (interactive) (dired-move-to-filename)))
  )
#+END_SRC
*** 対話的にls オプションを変更
`dired-sort-toggle' の代わりのつもり．
#+BEGIN_SRC emacs-lisp +n
(defvar dired-my-switch-prompt
  (concat
   (propertize "-n" 'face font-lock-builtin-face) ": name   "
   (propertize "-t" 'face font-lock-builtin-face) ": date   "
   (propertize "-v" 'face font-lock-builtin-face) ": version   "
   (propertize "-S" 'face font-lock-builtin-face) ": size   "
   (propertize "-X" 'face font-lock-builtin-face) ": extension   "
   (propertize "-a" 'face font-lock-builtin-face) ": all   "
   (propertize "-A" 'face font-lock-builtin-face) ": almost   "
   (propertize "-h" 'face font-lock-builtin-face) ": human-readable   "
   (propertize "-r" 'face font-lock-builtin-face) ": reverse   "
   (propertize "-g" 'face font-lock-builtin-face) ": group-directory"
   "\n"
   (propertize "Switches: " 'face font-lock-keyword-face)
   "%s"))

(defun dired-my-switch-change-interactive ()
  "Change dired sort switch interactively."
  (interactive)
  (let ((switch dired-actual-switches) key)
    (catch 'quit
      (while t
        (case (setq key (read-char (format dired-my-switch-prompt switch)))
          (?\C-m (setq dired-actual-switches switch)
                 (setq mode-name
                       (concat "Dired/" (dired-my-switch-short-expression)))
                 (dired-revert)
                 (throw 'quit t))
          (?q (throw 'quit t))
          ((?a ?A) (setq switch (dired-my-switch-all-option switch key)))
          ((?h ?r ?g) (setq switch (dired-my-switch-toggle-option switch key)))
          ((?  ?n ?t ?v ?S ?X) (setq switch (dired-my-switch-sort-option switch key)))
          (otherwise nil))))))

(defun dired-my-switch-all-option (switch key)
  "Change all switch."
  (case key
    (?a (dired-replace-in-string "-lA" "-la" switch))
    (?A (dired-replace-in-string "-la" "-lA" switch))))

(defun dired-my-switch-toggle-option (switch key)
  "Change toggle switch."
  (case key
    ((?h ?r)
     (if (string-match (format " -%s" (char-to-string key)) switch)
         (replace-match "" nil nil switch)
       (concat switch (format " -%s" (char-to-string key)))))
    (?g
     (if (string-match " --group-directories-first" switch)
         (replace-match "" nil nil switch)
       (concat switch " --group-directories-first")))))

(defun dired-my-switch-sort-option (switch key)
  "Change sort switch."
  (case key
    ((?  ?n)
     (dired-replace-in-string " -[tvSX]" "" switch))
    ((?t ?v ?S ?X)
     (if (string-match " -[tvSX]" switch)
         (if (string= (match-string 0 switch) (format " -%s" (char-to-string key)))
             (replace-match "" nil nil switch)
           (replace-match (format " -%s" (char-to-string key)) nil nil switch))
       (concat switch (format " -%s" (char-to-string key)))))))

(defun dired-my-switch-short-expression ()
  "Return short expression of `dired-actual-switches'."
  (let ((str dired-actual-switches))
    (setq str (replace-regexp-in-string "^-l" "" str))
    (setq str (replace-regexp-in-string " -\\([a-zA-Z]\\)" "\\1" str))
    (setq str (replace-regexp-in-string " --group-directories-first" "g" str))))

(add-hook 'dired-mode-hook
          (lambda ()
            (setq mode-name (concat "Dired/" (dired-my-switch-short-expression)))
            (define-key dired-mode-map (kbd "c") 'dired-my-switch-change-interactive)))
#+END_SRC
*** バッファ名に [Dired] を付加
#+BEGIN_SRC emacs-lisp +n
(defun dired-my-append-buffer-name-hint ()
  "Append a auxiliary string to a name of dired buffer."
  (when (eq major-mode 'dired-mode)
    (let* ((dir (expand-file-name list-buffers-directory))
           (drive (if (and (winp) ;; Windows の場合はドライブレターを追加
                           (string-match "^\\([a-zA-Z]:\\)/" dir))
                      (match-string 1 dir) "")))
      (rename-buffer (concat (buffer-name) " [" drive "Dired]") t))))
(add-hook 'dired-mode-hook 'dired-my-append-buffer-name-hint)
#+END_SRC
*** alternateなディレクトリ訪問
- [[http://www.bookshelf.jp/cgi-bin/goto.cgi?file=meadow&node=dired%20single][Meadow/Emacs memo: ディレクトリ表示 ― dired など]]
#+BEGIN_SRC emacs-lisp +n
(defun dired-find-file-dwim (&optional cancel)
 (interactive "P")
  (funcall (if (and (not cancel) (file-directory-p (dired-get-file-for-visit)))
               'dired-find-alternate-file
             'dired-find-file)))
(define-key dired-mode-map (kbd "RET") 'dired-find-file-dwim)
(define-key dired-mode-map (kbd "<right>") 'dired-find-file-dwim)

(defun dired-up-alternate-directory (&optional arg)
  (interactive "P")
  (set-buffer-modified-p nil)
  (let ((dir default-directory)
        (parent (expand-file-name "../" default-directory)))
    (funcall (if arg 'find-file-other-window 'find-alternate-file) parent)
    (dired-goto-file dir)))
(define-key dired-mode-map (kbd "^") 'dired-up-alternate-directory)
(define-key dired-mode-map (kbd "<left>") 'dired-up-alternate-directory)
#+END_SRC
*** キーバインド
#+BEGIN_SRC emacs-lisp +n
(define-key dired-mode-map (kbd "M-m") '(lambda () (interactive) (dired-move-to-filename)))
;;; C-t が image-なんたら の prefix で潰れているので unset
(define-key dired-mode-map (kbd "C-t") nil)
#+END_SRC
*** Dired で関連付けられたファイルを起動する
- [[http://ergoemacs.org/emacs/emacs_dired_open_file_in_ext_apps.html][Emacs Dired: Opening Files in External Apps]]
#+BEGIN_SRC emacs-lisp +n
(defun my-external-open-file  (file)
  "Open FILE with an appropriate application.
Works in Microsoft Windows, Mac OS X, Linux."
  (interactive "fOpen file with external application: ")
  (cond ((string-equal system-type "windows-nt")
         (w32-shell-execute "open" (replace-regexp-in-string "/" "\\" file t t)))
        ((string-equal system-type "darwin")
         (let ((process-connection-type nil))
           (start-process "" nil "open" file)))
        ((string-equal system-type "gnu/linux")
         (let ((process-connection-type nil))
           (start-process "" nil "xdg-open" file)))))
(defun my-external-open-file-dwim ()
  "Open the current file or dired marked files in external application."
  (interactive)
  (let ((file-list
         (cond ((string-equal major-mode "dired-mode") (dired-get-marked-files))
               ((and (featurep 'ffap) (ffap-file-at-point))
                (list (expand-file-name (ffap-file-at-point) default-directory)))
               (t (list (or (buffer-file-name)
                            (error "This buffer isn't visiting a file")))))))
    (when (or (<= (length file-list) 5)
              (y-or-n-p "Open more than 5 files?"))
      (mapc 'my-external-open-file file-list))))
(add-hook 'dired-mode-hook
          (lambda ()
            (define-key dired-mode-map "z" 'my-external-open-file-dwim))) ;;; 関連付け
(define-key my-original-map (kbd "C-o") 'my-external-open-file-dwim)
#+END_SRC
*** ファイル名のみで isearch
#+BEGIN_SRC emacs-lisp +n
(setq dired-isearch-filenames 'dwim)        ; dired-aux で定義されている．これだけで十分だった
#+END_SRC
*** dired バッファは折り返さない
#+BEGIN_SRC emacs-lisp +n
(add-hook 'dired-mode-hook
          (lambda ()
            (toggle-truncate-lines 1)))
#+END_SRC
*** すべてのファイルにマークする
#+BEGIN_SRC emacs-lisp +n
(defun dired-my-mark-all-files ()
  "Mark all files in a current dired buffer."
  (interactive)
  (dired-mark-files-regexp ""))

(defun dired-my-get-number-of-marked-files ()
  "Get the number of marked files."
  (interactive)
  (let ((case-fold-search nil)
        (mark-regexp "^\\*\\|^D")
        (count 0))
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward mark-regexp nil t)
        (setq count (1+ count))))
    count))

(defadvice dired-unmark-all-marks (around dired-my-mark-all-marks-dwim activate)
  "Mark all files or unmark all marks."
  (if (> (dired-my-get-number-of-marked-files) 0)
      ad-do-it
    (dired-my-mark-all-files)))
(define-key dired-mode-map (kbd "U") 'dired-unmark-all-marks)
#+END_SRC
*** dired で文字コード一括変換
- [[http://www.bookshelf.jp/cgi-bin/goto.cgi?file=meadow&node=dired%20convert%20code][Meadow/Emacs memo: ディレクトリ表示 ― dired など]]
#+BEGIN_SRC emacs-lisp +n
(defvar dired-default-file-coding-system nil
  "*Default coding system for converting file (s).")

(defvar dired-file-coding-system 'no-conversion)

(defun dired-convert-coding-system ()
  (let ((file (dired-get-filename))
        (coding-system-for-write dired-file-coding-system)
        failure)
    (condition-case err
        (with-temp-buffer
          (insert-file file)
          (write-region (point-min) (point-max) file))
      (error (setq failure err)))
    (if (not failure)
        nil
      (dired-log "convert coding system error for %s:\n%s\n" file failure)
      (dired-make-relative file))))

(defun dired-do-convert-coding-system (coding-system &optional arg)
  "Convert file (s) in specified coding system."
  (interactive
   (list (let ((default (or dired-default-file-coding-system
                            buffer-file-coding-system)))
           (read-coding-system
            (format "Coding system for converting file (s) (default, %s): "
                    default)
            default))
         current-prefix-arg))
  (check-coding-system coding-system)
  (setq dired-file-coding-system coding-system)
  (dired-map-over-marks-check
   (function dired-convert-coding-system) arg 'convert-coding-system t))
(define-key dired-mode-map (kbd "F") 'dired-do-convert-coding-system)
#+END_SRC
*** パスをコピーする
#+BEGIN_SRC emacs-lisp +n
(defun dired-copy-path (&optional full)
  "Copy a path of a file on current line.

If FULL is non-nil, copy a path as full path.  Otherwise copy as
relative path."
  (interactive "P")
  (let* ((path (dired-get-filename (not full)))
         (standard-path (if (winp)
                            (replace-regexp-in-string "/" "\\\\" path)
                          path)))
    (kill-new standard-path)
    (message "Copy \"%s\"" standard-path)))
(define-key dired-mode-map (kbd ";") 'dired-copy-path)
#+END_SRC
*** 最後のカッコ
#+BEGIN_SRC emacs-lisp +n
  )
#+END_SRC
** diff.el
- [[http://www.clear-code.com/blog/2012/4/3.html][Emacs上でカラフルにdiffを表示する - ククログ(2012-04-03)]]
#+BEGIN_SRC emacs-lisp +n
(use-package diff :defer t
  :config
;; diffを表示したらすぐに文字単位での強調表示も行う
(defun diff-mode-refine-automatically ()
  (diff-auto-refine-mode t))
(add-hook 'diff-mode-hook 'diff-mode-refine-automatically)
  )
#+END_SRC
** winner.el
ウィンドウ構成の変更履歴を辿れる．
#+BEGIN_SRC emacs-lisp +n
(use-package winner :defer t
  :commands (winner-undo winner-redo)
  :init
  (bind-key "C-/" 'winner-undo my-original-map)
  :config
  (winner-mode 1))
#+END_SRC
** whitespace.el
- [[http://d.hatena.ne.jp/syohex/20110119/1295450495][whitespace-modeの設定 - Life is very short]]
空白文字類を明示する。
#+BEGIN_SRC emacs-lisp +n
(use-package whitespace
  :config
  (setq whitespace-style '(face spaces space-mark tabs tab-mark trailing))
  (setq whitespace-display-mappings
        '((space-mark ?\u3000 [?\u25a1])
          (newline-mark ?\n    [?\u21B5 ?\n] [?$ ?\n])
          ;; WARNING: the mapping below has a problem.
          ;; When a TAB occupies exactly one column, it will display the
          ;; character ?\xBB at that column followed by a TAB which goes to
          ;; the next TAB column.
          ;; If this is a problem for you, please, comment the line below.
          (tab-mark     ?\t    [?\xBB ?\t]   [?\\ ?\t])))
  (setq whitespace-space-regexp "\\(\u3000+\\)") ; 全角空白のみを明示
  ;; フェイス設定
  (face-spec-set 'whitespace-tab
                 '((t :foreground "green")))
  (face-spec-set 'whitespace-trailing
                 '((t :foreground "green" :background unspecified
                      :weight unspecified :underline t)))
  (face-spec-set 'whitespace-newline
                 '((t :foreground "gray50")))
  (setq whitespace-global-modes '(not direx:direx-mode)) ; direx:direx-mode は global から除外する
  (global-whitespace-mode 1)
  )
#+END_SRC
** align.el
#+BEGIN_SRC emacs-lisp +n
(use-package align :defer t
  :init
  (bind-key "C-a" 'align my-original-map)
  :config
  (add-to-list 'align-rules-list
               '(pukiwiki-table-alignment
                 (regexp . "\\([ \t]*\\)|")
                 (spacing . 0)
                 (repeat . t)
                 (modes . '(pukiwiki-edit-mode))))
  )
#+END_SRC
** flyspell.el
編集中にリアルタイムにスペルチェックする．
#+BEGIN_SRC emacs-lisp +n
(use-package flyspell :defer t)
#+END_SRC
** outline.el
アウトラインを確認しながら編集するモード．主な目的は `outline-minor-mode' を
使うため．
#+BEGIN_SRC emacs-lisp +n
(use-package outline :defer t
  :config
  ;; make outline-level buffer local variable
  (make-variable-buffer-local 'outline-level)
  (setq-default outline-level 'outline-level)
  (make-variable-buffer-local 'outline-regexp-alist)
  ;; (define-key my-original-map (kbd "C-n") 'outline-next-visible-heading)
  ;; (define-key my-original-map (kbd "C-p") 'outline-previous-visible-heading)
  (defadvice outline-next-visible-heading (after recenter-after activate)
    (when (called-interactively-p 'any)
       (recenter)))
  (defadvice outline-previous-visible-heading (after recenter-after activate)
    (when (called-interactively-p 'any)
       (recenter)))
  )
#+END_SRC
** tramp.el
リモートにあるサーバのファイルを編集する．
#+BEGIN_SRC emacs-lisp +n
(use-package tramp :defer t
  :custom
  (tramp-persistency-file-name (my-locate-user-tmp-file "tramp"))
  :config
  (setq tramp-default-method (cond ((winp) "plinkx")
                                   (t "ssh")))

  ;; config for using cygwin ssh on Windows. Please use "sshx" method.
  ;; http://www.emacswiki.org/emacs/TrampMode
  (when (winp)
    (nconc (cadr (assq 'tramp-login-args (assoc "ssh" tramp-methods)))
           '(("bash" "-i")))
    ;; (setcdr (assq 'tramp-remote-sh (assoc "ssh" tramp-methods))
    ;;         '("bash -i"))
    )
  ;; multi ssh
  (add-to-list 'tramp-default-proxies-alist
               '("\\`rubner\\'" "\\`root\\'" "/kai@%h:"))
  ;(add-to-list 'tramp-default-proxies-alist
  ;             '("rubner-\\(dns\\|web\\)\\(.kaichan.mydns.jp\\)?" nil "/kai@rubner:"))
#+END_SRC
*** tramp バッファ名にホスト名などのヒントを追加する
#+BEGIN_SRC emacs-lisp +n
  (defun tramp-my-append-buffer-name-hint ()
    "Append a hint (user, hostname) to a buffer name if visiting
file is a remote file (include directory)."
    (let ((name (or list-buffers-directory (buffer-file-name))))
      (when (and name (tramp-tramp-file-p name))
        (let* ((tramp-vec (tramp-dissect-file-name name))
               (method (tramp-file-name-method tramp-vec))
               (host (if (fboundp 'tramp-file-name-real-host)
                         (tramp-file-name-real-host tramp-vec)
                       (tramp-file-name-host tramp-vec)))
               (user (or (if (fboundp 'tramp-file-name-real-user)
                             (tramp-file-name-real-user tramp-vec)
                           (tramp-file-name-user tramp-vec))
                         (nth 2 (assoc method tramp-default-user-alist))
                         tramp-default-user
                         user-real-login-name)))
          (rename-buffer (concat (buffer-name) " <" user "@" host ">") t)))))
  (add-hook 'find-file-hook 'tramp-my-append-buffer-name-hint)
  (add-hook 'dired-mode-hook 'tramp-my-append-buffer-name-hint)
#+END_SRC
*** モードラインの色を変える
- [[http://emacs.stackexchange.com/questions/17984/how-to-change-mode-line-color-based-on-host][themes - How to change mode line color based on host? - Emacs Stack Exchange]]
#+BEGIN_SRC emacs-lisp +n
  (defvar tramp-my-modeline-color "medium purple" "modline color for tramp buffers")
  (defun tramp-my-modeline-color ()
    "Change a modeline color of TRAMP buffer."
    (let ((name (or list-buffers-directory (buffer-file-name))))
      (when (and name (tramp-tramp-file-p name))
          (face-remap-add-relative 'mode-line (list :background tramp-my-modeline-color)))))
  (add-hook 'find-file-hook 'tramp-my-modeline-color)
  (add-hook 'dired-mode-hook 'tramp-my-modeline-color)
#+END_SRC
*** 最後のカッコ
#+BEGIN_SRC emacs-lisp +n
  )
#+END_SRC
** doc-view.el
Emacs で pdf 閲覧する．
#+BEGIN_SRC emacs-lisp +n
(use-package doc-view :defer t
  :config
  (setq doc-view-continuous t)     ; move next page if execute next-line on bottom edge of image
  (define-key doc-view-mode-map (kbd "l") 'image-forward-hscroll)
  (define-key doc-view-mode-map (kbd "h") 'image-backward-hscroll)
  (define-key doc-view-mode-map (kbd "j") 'doc-view-next-line-or-next-page)
  (define-key doc-view-mode-map (kbd "k") 'doc-view-previous-line-or-previous-page)
  (define-key doc-view-mode-map (kbd "f") 'image-scroll-up)
  (define-key doc-view-mode-map (kbd "b") 'image-scroll-down)
  (define-key doc-view-mode-map (kbd "C-t") nil) ; もともとのコマンドは doc-view-show-tooltip

  ;; to move to next page on the edge of page
  (defadvice image-scroll-up (around image-scroll-up-or-next-page activate)
    (let ((vscroll (window-vscroll))
          (hscroll (window-hscroll)))
      ad-do-it
      (when (and doc-view-continuous (= vscroll (window-vscroll)))
        (doc-view-next-page)
        (image-bob)
        (set-window-hscroll (selected-window) hscroll))))
  (defadvice image-scroll-down (around image-scroll-down-or-previous-page activate)
    (let ((vscroll (window-vscroll))
          (hscroll (window-hscroll)))
      ad-do-it
      (when (and doc-view-continuous (= vscroll (window-vscroll)))
        (doc-view-previous-page)
        (image-eob)
        (set-window-hscroll (selected-window) hscroll))))
  )
#+END_SRC
** cua-mode.el
矩形範囲の編集を便利にする．
#+BEGIN_SRC emacs-lisp +n
(cua-selection-mode 1)
(defun cua-my-dec-rectangle (decriment)
  "Decrement each line of CUA rectangle by prefix amount."
  (interactive "p")
  (cua-incr-rectangle (- decriment)))
(define-key cua--rectangle-keymap (kbd "M-d") 'cua-my-dec-rectangle)
#+END_SRC
** sh-script.el
#+BEGIN_SRC emacs-lisp +n
(use-package sh-script :defer t
  :config
  (setq-default sh-basic-offset 2)
  (setq-default sh-indentation 2))
#+END_SRC
** info.el
info を Emacs で読む．
#+BEGIN_SRC emacs-lisp +n
(use-package info :defer t
  :config
  (define-key Info-mode-map (kbd "M-n") nil) ; clone-buffer とかいう無駄なものが割り当てられてたので無効にする
  (define-key Info-mode-map (kbd "f") 'Info-scroll-up) ; 元のコマンドの Info-follow-reference の利用価値がまだわからない
  (define-key Info-mode-map (kbd "b") 'Info-scroll-down) ; もとはただの beginning-of-buffer なので問題ない
  (define-key Info-mode-map (kbd "F") 'Info-history-forward)
  (define-key Info-mode-map (kbd "B") 'Info-history-back)
  (define-key Info-mode-map (kbd "j") 'next-line)
  (define-key Info-mode-map (kbd "k") 'previous-line)
  (define-key Info-mode-map (kbd "<f3>") 'Info-search-next)
  (define-key Info-mode-map (kbd "s-<f3>") 'Info-search-previous)
  (add-to-list 'Info-default-directory-list "/usr/share/info/" t)
#+END_SRC
*** info で Hit a Hint
あんまりうまく動かない．
#+BEGIN_SRC emacs-lisp +n
  (defun my-Info-HaH ()
    "Follow a node by hit-a-hint.
  リファレンス以外の部分も jaunte の候補が出てしまうので
  改良の余地有り"
    (interactive)
    (condition-case nil
        (progn
          (jaunte)
          (Info-follow-nearest-node))
      (quit nil)))
  (define-key Info-mode-map (kbd "e") 'my-Info-HaH)
#+END_SRC
*** 最後のカッコ
#+BEGIN_SRC emacs-lisp +n
  )
#+END_SRC
** ffap.el
カーソル近くのファイルや URL を find-file で開く．
#+BEGIN_SRC emacs-lisp +n
(ffap-bindings)
#+END_SRC
** desktop.el
セッションのバッファの状態を保存する(次回起動時に勝手にファイルを開いてくれる)．
#+BEGIN_SRC emacs-lisp +n
(use-package desktop
  :custom
  (desktop-dirname (my-locate-user-tmp-file "./"))
  ;; 保存しないファイルの正規表現
  (desktop-files-not-to-save "\\(^/[^/:]*:\\|\\.diary\\'\\)")
  ;; フレーム情報（フォントも含む）をリストアしない
  (desktop-restore-frames nil)
  ;; Emacs起動直後にリストアするファイル数。残りは遅延してリストアする
  (desktop-restore-eager 1)
  ;; ロックファイルがあってもロードする
  (desktop-load-locked-desktop t)
  :config
  (desktop-save-mode 1))
#+END_SRC
** uniquify.el
同じ名前のファイルを開く際にバッファ名にディレクトリ名を付加する．ファイル名が
かぶったときわかり易くなる．
#+BEGIN_SRC emacs-lisp +n
(use-package uniquify
  :ensure nil
  :config
  ;; filename<dir> 形式のバッファ名にする
  (setq uniquify-buffer-name-style 'post-forward-angle-brackets)
  ;; *で囲まれたバッファ名は対象外にする
  (setq uniquify-ignore-buffers-re "*[^*]+*"))
#+END_SRC
#+BEGIN_SRC emacs-lisp +n
(my-measure-message-time "Standard elisp setting.")
#+END_SRC
* 非標準ライブラリ
** [[https://github.com/magit/transient][transient.el]]
なんかよくわからん。magitのポップアップで使ってるっぽい。

#+BEGIN_SRC emacs-lisp +n
(use-package transient :defer t
  :custom
  (transient-history-file (my-locate-user-tmp-file "transient/history.el"))
  )
#+END_SRC
** [[https://github.com/editorconfig/editorconfig-emacs][editorconfig]]
~.editorconfig~ を読み取って、バッファのローカル変数を設定する。

#+BEGIN_SRC emacs-lisp +n
(use-package editorconfig
  :config
  (editorconfig-mode 1))
#+END_SRC
** ahk-mode
AutoHotkeyスクリプトのメジャーモード

#+BEGIN_SRC emacs-lisp +n
(use-package ahk-mode :defer t)
#+END_SRC
** [[https://github.com/alpha22jp/atomic-chrome][atomic-chrome]]
ブラウザのテキストエリアをEmacsで編集できるようにするパッケージ。Firefox側に [[https://addons.mozilla.org/en-US/firefox/addon/ghosttext/][GhostText]] というアドオンが必要なことに注意。WebSocketで通信しているみたいで、双方向に変更が同期できる。超イカしてる！

#+BEGIN_SRC emacs-lisp +n
(use-package atomic-chrome :defer 5
  :config
  (when (require 'markdown-mode nil t)
    ;; `markdown-mode' を読み込んでたらメジャーモードを `gfm-mode' にする
    (setq atomic-chrome-default-major-mode 'gfm-mode))
  (atomic-chrome-start-server)
  )
#+END_SRC

- [[https://gordiustears.net/using-ghosttext-for-firefox-quantum/][Firefox アドオン It’s All Text の代わりは GhostText が良さそう | ゴルディアスの涙目]]
** yaml-mode
#+BEGIN_SRC emacs-lisp +n
(use-package yaml-mode :defer t
  :mode "\\.yml\\'")
#+END_SRC
** emoji-cheat-sheet-plus
- [[https://github.com/syl20bnr/emacs-emoji-cheat-sheet-plus][Browse, insert and display Emoji emoticons in Emacs 💖]]

Markdownなどで使える絵文字表記を一覧、挿入するライブラリ。また =emoji-cheat-sheet-plus-display-mode= というマイナーモードを有効にすると、絵文字表記を絵文字の画像で表示してくれる。Markdownのお供にどうぞって感じですね。

例えば :+1: とか :family: をいい感じでみれるようになる。
#+BEGIN_SRC emacs-lisp +n
(use-package emoji-cheat-sheet-plus :defer t
  :init
  (add-hook 'markdown-mode-hook 'emoji-cheat-sheet-plus-display-mode)
  :bind (:map mode-specific-map
              ("e" . emoji-cheat-sheet-plus-insert))
  )
#+END_SRC

なんか別のマイナーモードとかと競合してる感があり、うまく =emoji-cheat-sheet-plus-display-mode= で画像が表示されないケースがある。Windowsだからだろうか。
** docker
*** dockerfile-mode
#+BEGIN_SRC emacs-lisp +n
(use-package dockerfile-mode :defer t
  :init
  ;; Open "*.dockerfile" with `dockerfile-mode'
  (add-to-list 'auto-mode-alist '("\\.[Dd]ockerfile\\'" . dockerfile-mode))
  )
#+END_SRC
*** docker-compose-mode
#+BEGIN_SRC emacs-lisp +n
(use-package docker-compose-mode :defer t)
#+END_SRC
*** docker-tramp
コンテナ内のファイルをTRAMPでいじれるライブラリ。=C-x C-f /docker:user@container:/path/to/file= でコンテナ内のファイルにアクセスできるようになる。

バージョン2.3より前のtrampはalpineコンテナでうまく動作しないバグ（[[https://lists.gnu.org/archive/html/tramp-devel/2016-05/msg00000.html][Bug when connecting to busybox sh]]）があるので、=docker-tramp-compat= を使用する。trampのバージョンが上がったら =docker-tramp= に変更する。
#+BEGIN_SRC emacs-lisp +n
(use-package docker-tramp-compat :defer t
  :ensure docker-tramp
  )
#+END_SRC
** dos-inent
- [[https://www.emacswiki.org/emacs/dos-indent.el][dos-indent.el]]
#+BEGIN_SRC emacs-lisp +n
(use-package dos-indent :defer t
  :ensure nil
  :commands dos-indent
  :init
  (with-eval-after-load 'bat-mode
    (add-hook 'bat-mode-hook 'dos-indent))
  )
#+END_SRC
** god-mode
#+BEGIN_SRC emacs-lisp +n
(use-package god-mode :defer t :disabled t
  :bind ("<escape>" . god-local-mode)
  :config
  (bind-keys :map god-local-mode-map
             ("z" . repeat)
             ("i" . god-local-mode))
  )
#+END_SRC
** evil-mode
#+BEGIN_SRC emacs-lisp +n
(use-package evil :disabled t
  :config
  ;; normal state key bindings
  (bind-keys :map evil-normal-state-map
             ("C-t" . nil)   ; `pop-tag-mark' の割り当て解除
             ("f" . scroll-up)
             ("b" . scroll-down))

  ;; ステートごとにモードラインの色を変える
  (defun evil-state-color ()
    "Change mode-line color according to `evil-state'."
    (let ((color (assoc-default evil-state
                                '((emacs . "gray75")
                                  (normal . "orange")
                                  (insert . "purple")))))
      (when color
        (set-face-background 'mode-line color))))
  (add-hook 'window-configuration-change-hook 'evil-state-color)

  (defun evil-emacs-state-modeline ()
    (set-face-background 'mode-line "gray75"))
  (defun evil-normal-state-modeline ()
    (set-face-background 'mode-line "orange"))
  (defun evil-insert-state-modeline ()
    (set-face-background 'mode-line "purple"))
  (add-hook 'evil-emacs-state-entry-hook
            'evil-emacs-state-modeline)
  (add-hook 'evil-normal-state-entry-hook
            'evil-normal-state-modeline)
  (add-hook 'evil-insert-state-entry-hook
            'evil-insert-state-modeline)

  (evil-mode 1) ; enable `evil-mode' in all buffers
  )
#+END_SRC
** kotlin-mode
#+BEGIN_SRC emacs-lisp +n
(use-package kotlin-mode :defer t
  :mode "\\.kts?\\'"
  :config
  (set-variable 'kotlin-tab-width 2)
  )
#+END_SRC
** typescript-mode
#+BEGIN_SRC emacs-lisp +n
(use-package typescript-mode :defer t
  :config
  (set-variable 'typescript-indent-level 2)
  )
#+END_SRC
*** tss
#+BEGIN_SRC emacs-lisp +n
(use-package tss :defer t)
#+END_SRC

tssは =json-mode= に依存しているのでここでロードしておく。
#+BEGIN_SRC emacs-lisp +n
(use-package json-mode :defer t
  :mode "\\.json\\'")
#+END_SRC
** autoit-mode
[[https://www.autoitscript.com/site/autoit/][AutoIt]]のスクリプトを編集するメジャーモード。
#+BEGIN_SRC emacs-lisp +n
(use-package autoit-mode :defer t :disabled t
  :mode "\\.au3\\'")
#+END_SRC
** js2-mode
#+BEGIN_SRC emacs-lisp +n
(use-package js2-mode :defer t
  :mode "\\.js\\'"
  :config
  (setq js2-basic-offset 2)
  (bind-keys :mode js2-mode-map
             ("C-." . js2-next-error)
             ("C-," . js2-previous-error))
  (defun js2-previous-error (&optional reset)
    (interactive)
    (js2-next-error -1 reset))
  )
#+END_SRC
** csv-mode
#+BEGIN_SRC emacs-lisp +n
(use-package csv-mode :defer t
  :config
  (bind-keys :map csv-mode-map
             ("TAB" . csv-forward-field)
             ("<backtab>" . csv-backward-field))
  (setq csv-invisibility-default nil)
  (setq csv-align-padding 0)
  ;; 桁ぞろえをトグルできるようにアドバイスする
  (defvar csv-aligned-p "Whether `csv-mode' is aligned" nil) ; should be buffer local
  (defadvice csv-align-fields (around toggle-align-state activate)
    (if csv-aligned-p
        (call-interactively #'csv-unalign-fields)
      ad-do-it)
    (setq csv-aligned-p (not csv-aligned-p)))
  )
#+END_SRC
** Golang関連
#+BEGIN_SRC emacs-lisp +n
(use-package go-mode :defer t
  :config
  ;; キーバインド
  (bind-key "C-c C-f" 'gofmt go-mode-map)
  (bind-key "C-c C-d" 'godoc-at-point go-mode-map)
  (use-package go-autocomplete)
  (use-package go-eldoc)
  (add-hook 'go-mode-hook 'go-eldoc-setup)
  ;; 他ライブラリ連携
  (with-eval-after-load 'popwin
    (add-to-list 'popwin:special-display-config
               '(godoc-mode :position right :width 80)))
  )
#+END_SRC
*** 参考
- [[http://emacs-jp.github.io/programming/golang.html][Goプログラミングの環境構築 - Emacs JP]]
** [[https://github.com/wildsoul/plantuml-mode][plantuml-mode]]
[[http://plantuml.com/index.html][PlantUML]]のUMLを編集するメジャーモード。plantuml-mode.elをロードするにはplantuml.jarを使用できるようにしておく必要がある。

なぜかplantuml.jarでUMLテキストを画像ファイルに変換するコマンドが定義されていないので =plantuml-execute= コマンドを自前で定義した。
#+BEGIN_SRC emacs-lisp +n
(use-package plantuml-mode :defer t
  :if (file-readable-p "C:/ProgramData/chocolatey/lib/plantuml/tools/plantuml.jar")
  :mode (("\\.uml\\'" . plantuml-mode))
  :config
  (set-variable 'plantuml-jar-path "C:/ProgramData/chocolatey/lib/plantuml/tools/plantuml.jar")
  ;; org-babelと連携
  (with-eval-after-load 'org
    ;; plantumlソースブロックを評価可能にする
    (org-babel-do-load-languages 'org-babel-load-languages
                                 (cons '(plantuml . t) org-babel-load-languages)))
  (with-eval-after-load 'ob-plantuml
    (setq org-plantuml-jar-path plantuml-jar-path)
    (add-to-list 'org-babel-default-header-args:plantuml
                 (cons :cmdline "-charset UTF-8"))
    (add-to-list 'org-my-evaluatable-languages "plantuml"))
    ;; @startuml～@enduml で囲まないように `org-babel-plantuml-make-body' を上書きする
    (defalias 'org-bable-plantuml-make-body-original #'org-babel-plantuml-make-body)
    (defun org-babel-plantuml-make-body (body params)
      "Not surround with @startuml/@enduml"
      (org-babel-expand-body:generic
       body params (org-babel-variable-assignments:plantuml params)))
  )
#+END_SRC

簡単なシーケンス図を書いてみる。
#+BEGIN_SRC plantuml :file ../images/auth-sequence.svg :cmdline -charset UTF-8 :exports both
@startuml
    クライアント -> サーバ: Authentication Request
    サーバ --> クライアント: Authentication Response
@enduml
#+END_SRC

#+CAPTION: 画像への変換結果
#+ATTR_HTML: :width 400 :alt 認証処理のシーケンス図 :title 認証処理 :border 1
#+RESULTS:
[[file:../images/auth-sequence.svg]]
*** 参考
- [[http://d.hatena.ne.jp/a_bicky/20121016/1350347857][Emacs から PlantUML を使ってみた - あらびき日記]]
- [[http://yohshiy.blog.fc2.com/blog-category-22.html][PlantUML | プログラマーズ雑記帳]]
** [[http://ppareit.github.io/graphviz-dot-mode/][graphviz-dot-mode]]
[[http://www.graphviz.org/][Graphviz]]のDOT記法を編集するメジャーモード。あらかじめ =compile-command= が設定されているので、 =compile= を実行するとDOTファイルが画像に変換される。
#+BEGIN_SRC emacs-lisp +n
(use-package graphviz-dot-mode :defer t
  :config
  (defun graphviz-dot-my-hook-function ()
    ;; 問い合わせなしでコンパイルする
    (set (make-local-variable 'compilation-read-command) nil))
  (add-hook 'graphviz-dot-mode-hook 'graphviz-dot-my-hook-function)
  ;; org-babel連携
  (with-eval-after-load 'org-src
    (setcdr (assoc "dot" org-src-lang-modes) 'graphviz-dot))
  (with-eval-after-load 'ob-dot
    (add-to-list 'org-my-evaluatable-languages "dot"))
  )
#+END_SRC
** [[https://github.com/sensorflo/adoc-mode][adoc-mode]]
[[http://www.methods.co.nz/asciidoc/][AsciiDoc]]編集用メジャーモード。
#+BEGIN_SRC emacs-lisp +n
(use-package adoc-mode :defer t
  :mode (("\\.asciidoc\\'" . adoc-mode)
         ("\\.adoc\\'"     . adoc-mode)
         ("\\.ad\\'"       . adoc-mode))
  )
#+END_SRC
** [[http://jblevins.org/projects/markdown-mode/][markdown-mode]]
Markdown編集用メジャーモード。Git Flavored Markdown用の =gfm-mode= も定義されている。
#+BEGIN_SRC emacs-lisp +n
(use-package markdown-mode :defer t
  ;; Use `gfm-mode' instead of `markdown-mode'
  :mode (("\\.markdown\\'" . gfm-mode)
         ("\\.mdown\\'"    . gfm-mode)
         ("\\.mkdn\\'"     . gfm-mode)
         ("\\.mkd\\'"      . gfm-mode)
         ("\\.md\\'"       . gfm-mode)
         ("\\.txt\\'"      . gfm-mode))
  :config
  (defun my-orgtbl-to-mdtbl (&optional beg end)
    "Convert a org-mode table into markdown one."
    (interactive)
    (setq beg (if (use-region-p) (region-beginning) (point-min))
          end (if (use-region-p) (region-end)       (point-max)))
    (save-excursion
      (goto-char beg)
      (while (re-search-forward "-\\+-" end t)
        (replace-match "-|-"))))
  ;; smartrep keybindginds
  (with-eval-after-load 'smartrep
    (smartrep-define-key markdown-mode-map "C-c"
      '(
        ("C-n" . markdown-next-visible-heading)
        ("C-p" . markdown-previous-visible-heading)
        ("C-f" . markdown-forward-same-level)
        ("C-b" . markdown-backward-same-level)
        ("C-u" . markdown-up-heading)
        )))
  ;; wrpa-region integration
  (with-eval-after-load 'wrap-region
    (wrap-region-add-wrapper "`" "`" nil 'markdown-mode)  ; verbose
    (wrap-region-add-wrapper "*" "*" nil 'markdown-mode)  ; em
    (wrap-region-add-wrapper "_" "_" nil 'markdown-mode)  ; em
    (wrap-region-add-wrapper "**" "**" ":" 'markdown-mode)   ; strong
    (wrap-region-add-wrapper "__" "__" "\\" 'markdown-mode)  ; strong
    (wrap-region-add-wrapper "~~" "~~" "~" 'markdown-mode)  ; strike
    )
  (defun my-markdown-mode-hook-function ()
    (orgtbl-mode 1)
    ;; automatically convert org-mode table into markdown one
    (add-hook 'before-save-hook #'my-orgtbl-to-mdtbl nil t)
    )
  (add-hook 'markdown-mode-hook #'my-markdown-mode-hook-function)
  (add-hook 'markdown-mode-hook #'flycheck-mode)
  )
#+END_SRC
** irfc
EmacsでRFCを閲覧する。RFCのダウンロードもしてくれる。
#+BEGIN_SRC emacs-lisp +n
(use-package irfc :defer t
  :ensure nil
  :init
  (set-variable 'irfc-assoc-mode t) ; irfc-modeを自動で有効にする
  :config
  (bind-keys :map irfc-mode-map
             ("<backspace>" . scroll-down)
             ("S-SPC" . scroll-down))
  (add-hook 'irfc-mode-hook #'read-only-mode)
  )
#+END_SRC
*** irfc-x
#+BEGIN_SRC emacs-lisp +n
(use-package irfc :defer t :disabled t)
#+END_SRC
** longlines-jp
日本語を考慮して =fill-column= で仮想的に折り返す。
#+BEGIN_SRC emacs-lisp +n
(use-package longlines-jp :defer t
  :ensure nil
  :commands longlines-jp-mode
  :init
  (bind-key "C-j" 'longlines-jp-mode my-original-map)
  (add-hook 'org-mode-hook
            #'longlines-jp-exclude-regex-for-org-mode)
  (defun longlines-jp-exclude-regex-for-org-mode ()
     (with-eval-after-load 'longlines-jp
       (setq longlines-jp-exclude-regex
             (rx bol (* space) (or "#+" "*" ":" "|")))))
  :config
  (setq skk-henkan-mode nil
        skk-current-rule-tree nil)
  (setq longlines-jp-show-hard-newlines t)
  )
#+END_SRC
** mykie
状況に応じて実行するコマンドを切り替えることができるライブラリ。
#+BEGIN_SRC emacs-lisp +n
(use-package mykie
  :config
  (mykie:define-key-with-self-key
      "r" :region my-query-replace-region-to
          :region&C-u (my-query-replace-region-to t))
  (defun my-query-replace-region-to (&optional whole)
    (let* ((from (buffer-substring-no-properties (region-beginning) (region-end)))
           (to (read-string (format "Query replace %s with: " from))))
      (save-excursion
        (goto-char (if whole (point-min) (region-beginning)))
        (deactivate-mark)
        (query-replace from to))))
  )
#+END_SRC
** visual-basic-mode
VBの編集用メジャーモード。
#+BEGIN_SRC emacs-lisp +n
(use-package visual-basic-mode :defer t
  :ensure nil
  :mode (("\\.vb\\'"  . visual-basic-mode)
         ("\\.vbs\\'" . visual-basic-mode)
         ("\\.dcm\\'" . visual-basic-mode)
         ("\\.bas\\'" . visual-basic-mode)
         ("\\.frm\\'" . visual-basic-mode)
         ("\\.cls\\'" . visual-basic-mode))
  :init
  (defun visual-basic-mode-hook-function ()
    (set (make-local-variable 'outline-regexp) "^\\(Private\\|Public\\|Sub\\|Function\\|Dim\\)")
    (set (make-local-variable 'outline-level) 'visual-basic-mode-outline-level)
    )
  (defun visual-basic-mode-outline-level ()
    1)
  (add-hook 'visual-basic-mode-hook 'visual-basic-mode-hook-function)
  :config
  (setq visual-basic-mode-indent 4)
  (with-eval-after-load 'auto-complete
    '(add-to-list 'ac-modes 'visual-basic-mode))
  (defun visual-basic-combine ()
    (interactive)
    (let* ((file (or (buffer-file-name (current-buffer))
                     (error "Invalid file")))
           (vbac-command (expand-file-name "../../vbac.wsf"
                                           (file-name-directory file))))
      (shell-command (concat "cscript " vbac-command " combine"))))
  (define-key visual-basic-mode-map (kbd "C-c C-c") 'visual-basic-combine)
  (defun visual-basic-decombine ()
    (interactive)
    (let* ((file (or (buffer-file-name (current-buffer))
                     (error "Invalid file")))
           (vbac-command (expand-file-name "../../vbac.wsf"
                                           (file-name-directory file))))
      (shell-command (concat "cscript " vbac-command " decombine"))))
  (define-key visual-basic-mode-map (kbd "C-c C-d") 'visual-basic-decombine)
  (defun visual-basic-open-binary ()
    (interactive)
    (let* ((file (or (buffer-file-name (current-buffer))
                     (error "Invalid file")))
           (binary-name (file-name-nondirectory (expand-file-name ".." file)))
           (binary (expand-file-name
                    (concat "../../bin/" binary-name)
                    (file-name-directory file))))
      (if (file-exists-p binary)
          (org-open-file-with-system binary)
        (error (concat "File not found: " binary)))))
  (define-key visual-basic-mode-map (kbd "C-c C-o") 'visual-basic-open-binary)
  )
#+END_SRC
** powershell-mode
#+BEGIN_SRC emacs-lisp +n
(use-package powershell :defer t
  :config
  (setq powershell-indent 2)
  )
#+END_SRC
** zeal-at-point
#+BEGIN_SRC emacs-lisp +n
(use-package zeal-at-point :defer t
  :init
  (bind-key "d" 'zeal-at-point mode-specific-map))
#+END_SRC
** exec-path-from-shell
Windowsだと動かないくさい。
#+BEGIN_SRC emacs-lisp +n
(use-package exec-path-from-shell
  :if (not (winp))
  :config
  (exec-path-from-shell-initialize))
#+END_SRC
** gradle-mode
Gradleタスクを実行するマイナーモード。
#+BEGIN_SRC emacs-lisp +n
(use-package gradle-mode :defer t
  :init
  (autoload 'gradle-major-mode "gradle-mode")
  (add-to-list 'auto-mode-alist '("\\.gradle\\'" . gradle-major-mode))
  :config
  ;; gradle-mode sholud be major-mode
  (define-derived-mode gradle-major-mode groovy-mode "GradleM"
    (use-local-map gradle-mode-map))
  )
#+END_SRC
** groovy-mode
#+BEGIN_SRC emacs-lisp +n
(use-package groovy-mode :defer t
  :config
  ;; spockのデータテーブルを桁揃えする設定
  (with-eval-after-load 'align
    (add-to-list 'align-rules-list
                 '(spock-table-align
                   (regexp . "\\([ \t]*\\)|+")
                   (spacing . 1)
                   (repeat . t)
                   (modes . '(groovy-mode)))))
  )
#+END_SRC
** flyckeck
- [[https://www.flycheck.org/en/latest/][Flycheck — Syntax checking for GNU Emacs — Flycheck 32-cvs documentation]]

オンザフライのシンタックスチェッカー。とはいいつつ ~flycheck~ 自体はチェッカーのためのフレームワークといったほうが良さそう。シンタックスのチェック自体は言語に応じた外部ツールにお任せして、そのツールの出力を ~flycheck~ が解釈してバッファにチェック結果を表示できる仕組みになっている。

#+BEGIN_SRC emacs-lisp +n
(use-package flycheck :defer t
  :init
  (add-hook 'prog-mode-hook 'flycheck-mode)
  :bind (("C-," . previous-error)
         ("C-." . next-error))
  :config
  (setq flycheck-idle-change-delay 0.5)
  (setq flycheck-display-errors-delay 0.1)
  ;; Configuration for textlint checker
  (set-variable 'flycheck-textlint-config ".textlintrc")
  (defun flycheck-textlint-my-project-executable-find ()
    "Find textlint executable for a node project."
    (let ((root (locate-dominating-file
                 (or (buffer-file-name) default-directory)
                 (lambda (dir)
                   (let ((textlint (expand-file-name "node_modules/textlint/bin/textlint.js" dir)))
                     (and textlint (file-exists-p textlint)))))))
      (when root
        (let ((textlint (expand-file-name "node_modules/.bin/textlint" root)))
          (setq-local flycheck-textlint-executable textlint)
          ;; project textlint automatically searches a .textlintrc.{json,yml,js}
          ;; when `flycheck-textlint-config' is nil.
          (setq-local flycheck-textlint-config nil)))
      ))
  (add-hook 'flycheck-mode-hook #'flycheck-textlint-my-project-executable-find)
  )
#+END_SRC
*** textlintで文章校正
+チェッカーの作り方は[[https://gist.github.com/PharaohKJ/cc849ad12ca613fec9604e5e91012ffc][こちら]]を参考にした。=--preset= とか =--rule= の部分は変数にしたいところ。+

[[https://github.com/flycheck/flycheck/pull/1534][Add textlint checker by kisaragi-hiu · Pull Request #1534 · flycheck/flycheck]] で ~flycheck~ の組み込みのtextlintチェッカーが追加されたので、独自に定義する必要はなくなったよ。
*** エラーのインライン表示
~flycheck~ でデフォルトのエラー表示方法は ~flycheck-display-error-messages~ であり、これはミニバッファにメッセージを表示する。が、ミニバッファにいちいち視線を移動するより、エラー箇所のすぐそばにメッセージを表示してくれたほうがありがたい。

それを実現するのが [[https://github.com/flycheck/flycheck-inline][flycheck/flycheck-inline: Display Flycheck errors inline]] である。

#+BEGIN_SRC emacs-lisp +n
(with-eval-after-load 'flycheck
  (use-package flycheck-inline
    :init (add-hook 'flycheck-mode-hook #'flycheck-inline-mode)
    :config
    ;; 本文と区別がつくように背景色を灰色にする
    (cl-loop for face
         in (list 'flycheck-inline-error 'flycheck-inline-warning 'flycheck-inline-info)
         do
         (face-spec-set face
                        '((((class color) (background light))
                           :background "gray90")
                          (((class color) (background dark))
                           :background "gray25")))
         )
    ;; メッセージをインデントしないように再定義する
    (defun flycheck-inline-indent-message (offset msg)
      "Modified version of `flycheck-inline-indent-message'.

OFFSET is simply ignored."
      (let* ((pad (make-string 0 ?\s))  ; force indent width to 0
             (rep (concat "\n" pad)))
        (concat pad
                (replace-regexp-in-string "\n" rep (string-trim msg)))))
    ))
#+END_SRC
** git-gutter-fringe
#+BEGIN_SRC emacs-lisp +n
(use-package git-gutter-fringe :defer t
  :commands
  (git-gutter-mode global-git-gutter-mode git-gutter:toggle git-gutter:next-hunk
   git-gutter:previous-hunk git-gutter:stage-hunk git-gutter:revert-hunk git-gutter:popup-hunk)
  :init
  (define-prefix-command 'git-gutter-prefix)
  (define-key git-gutter-prefix (kbd "RET") 'git-gutter-mode)
  (define-key git-gutter-prefix (kbd "n") 'git-gutter:next-hunk)
  (define-key git-gutter-prefix (kbd "p") 'git-gutter:previous-hunk)
  (define-key git-gutter-prefix (kbd "s") 'git-gutter:stage-hunk)
  (define-key git-gutter-prefix (kbd "r") 'git-gutter:revert-hunk)
  (define-key git-gutter-prefix (kbd "d") 'git-gutter:popup-hunk)
  (with-eval-after-load 'key-chord
    (key-chord-define global-map ":g" 'git-gutter-prefix))
  )
#+END_SRC
** smart-newline
スマートに改行を入れる。
#+BEGIN_SRC emacs-lisp +n
(use-package smart-newline :defer t
  :init
  (add-hook 'prog-mode-hook 'smart-newline-mode)
  (add-hook 'text-mode-hook 'smart-newline-mode))
#+END_SRC
** ace-jump-mode
るびきちメルマガより。
#+BEGIN_SRC emacs-lisp +n
(use-package ace-jump-mode :defer t
  :init
  (add-autoload isearch-forward ace-jump-mode)
  :config
  (set-variable 'ace-jump-mode-move-keys
                (list ?a ?s ?d ?f ?g ?h ?j ?j ?k ?l
                      ?q ?w ?e ?r ?t ?y ?u ?i ?o ?p))

  (defun ace-jump-from-isearch ()
    "Invoke `ace-jump' from isearch."
    (interactive)
    (isearch-exit)
    (goto-char isearch-opoint)
    (if ace-jump-current-mode (ace-jump-done))
    (setq ace-jump-current-mode 'ace-jump-char-mode)
    (ace-jump-do isearch-string))
  (define-key isearch-mode-map (kbd "C-M-s") 'ace-jump-from-isearch)

  (defvar isearch-ace-jump-mode-timer nil)
  (defvar isearch-ace-jump-mode-interval 0.2)

  (defun isearch-mode-hook--ace-jump-mode ()
    (when (and (not isearch-ace-jump-mode-timer)
               (not isearch-regexp)
               isearch-ace-jump-mode-interval)
      (run-at-time 3 nil 'set 'ring-bell-function ring-bell-function)
      (setq ring-bell-function 'ignore)
      (setq isearch-ace-jump-mode-timer
            (run-with-idle-timer isearch-ace-jump-mode-interval t
                                 'isearch-ace-jump-timer-function))))
  (add-hook 'isearch-mode-hook 'isearch-mode-hook--ace-jump-mode)
  (defun isearch-ace-jump-timer-function ()
    (when (= (length isearch-string) 1)
      (isearch-ace-jump-cancel-timer)
      (setq quit-flag t)
      (run-with-idle-timer 0 nil 'message "")
      (ace-jump-from-isearch)))
  (defun isearch-ace-jump-cancel-timer ()
    (when isearch-ace-jump-mode-timer
      (cancel-timer isearch-ace-jump-mode-timer)
      (setq isearch-ace-jump-mode-timer nil)))
  (add-hook 'isearch-mode-end-hook 'isearch-ace-jump-cancel-timer)
  )
#+END_SRC
** org-octopress
org-modeでOctpressの記事を書くためのライブラリ。
#+BEGIN_SRC emacs-lisp +n
(use-package org-octopress :defer t
  :commands (org-octopress)
  :config
  (defvar octopress-directory (expand-file-name "octopress" dropbox-directory))
  (setq org-octopress-directory-top       (expand-file-name "source" octopress-directory))
  (setq org-octopress-directory-posts     (expand-file-name "source/_posts" octopress-directory))
  (setq org-octopress-directory-org-top   (expand-file-name "source" octopress-directory))
  (setq org-octopress-directory-org-posts (expand-file-name "source/blog" octopress-directory))
  (setq org-octopress-setup-file          (expand-file-name "org-octopress/style.org" octopress-directory))
  (setq org-jekyll-comments "true")
  )
#+END_SRC
** outline-magic
outline-modeでorg-cycle風にアウトラインを開閉する。
#+BEGIN_SRC emacs-lisp +n
(use-package outline-magic :defer t
  :config
  (define-key outline-minor-mode-map (kbd "<C-tab>") 'outline-cycle))
#+END_SRC
** anzu
#+BEGIN_SRC emacs-lisp +n
(use-package anzu :defer t
  :init
  :config
  (global-anzu-mode)
  (setq anzu-minimum-input-length 3)
  (when (executable-find "cmigemo") (setq anzu-use-migemo t))
  (global-set-key (kbd "M-%") 'anzu-query-replace)
  (global-set-key (kbd "C-M-%") 'anzu-query-replace-regexp))
#+END_SRC
** zoom-window
ウィンドウを一時的に1ウィンドウにする。
#+BEGIN_SRC emacs-lisp +n
(use-package zoom-window :defer t
  :init
  (bind-key "C-1" 'zoom-window-zoom)
  :config
  (setq zoom-window-use-elscreen t)
  (zoom-window-setup)
  )
#+END_SRC
** highlight-symbol-mode
カーソル下のシンボルをハイライトする。highlight-symbol-mode は自動的にカーソ
ル下のシンボルをハイライトするようになる。
#+BEGIN_SRC emacs-lisp +n
(use-package highlight-symbol :defer t
  :init
  (add-hook 'prog-mode-hook 'highlight-symbol-mode)
  :config
  (setq highlight-symbol-idle-delay 0.5)
  )
#+END_SRC
** emmet-mode
#+BEGIN_SRC emacs-lisp +n
(use-package emmet-mode :defer t
  :config
  (setq emmet-preview-default nil)
  (defun emmet-cheat-sheet ()
    (interactive)
    (browse-url "http://docs.emmet.io/cheat-sheet/"))
  )
#+END_SRC
** direx.el
- [[http://cx4a.blogspot.jp/2011/12/popwineldirexel.html][LOAD-TIME-VALUE: popwin.elと相性が良いシンプルなディレクトリ・エクスプローラ、direx.elを作りました]]
- [[http://d.hatena.ne.jp/syohex/20130202/1359814263][direx.elの設定 - Life is very short]]
ツリー表示ができる dired．ファイルを操作する機能はまだ限定的．
#+BEGIN_SRC emacs-lisp +n
(use-package direx :defer t
  :commands direx:my-jump
  :bind ("C-x C-d" . direx:my-jump)
  :config
  ;; アイコンに画像を使う
  ;(let ((dir (expand-file-name "images/tree-widget/folder/" data-directory)))
  ;  (setq direx:leaf-icon
  ;        (propertize "l "
  ;                    'display (create-image (expand-file-name "leaf.xpm" dir))
  ;                    'help-echo "Open file")
  ;        direx:closed-icon
  ;        (propertize "c "
  ;                    'display (create-image (expand-file-name "close.xpm" dir))
  ;                    'help-echo "Open tree")
  ;        direx:open-icon
  ;        (propertize "o "
  ;                    'display (create-image (expand-file-name "open.xpm" dir))
  ;                    'help-echo "Close tree")))
  ;; アイコンの設定
  (setq direx:leaf-icon   "- "
        direx:closed-icon "> "
        direx:open-icon   "v ")
  ;; キーバインド
  (bind-keys :map direx:direx-mode-map
             ("l" . direx:down-item)
             ("h" . direx:up-item)
             ("j" . direx:next-item)
             ("k" . direx:previous-item)
             ("d" . direx:down-item)
             ("u" . direx:up-item)
             ("f" . direx:next-sibling-item)
             ("b" . direx:previous-sibling-item))
  ;; popwin 設定に追加
  (with-eval-after-load 'popwin
    (push '(direx:direx-mode :position left :width 40 :dedicated t)
            popwin:special-display-config))
  ;; my function
  (defun direx:my-external-open-item-at-point (&optional point)
    "Externally Open direx item."
    (interactive)
    (let* ((item (direx:item-at-point point))
           (file (direx:file-full-name (direx:item-tree item))))
      (my-external-open-file file)))
  (define-key direx:direx-mode-map (kbd "z") 'direx:my-external-open-item-at-point)

  (defun direx:my-jump (arg)
    ""
    (interactive "P")
    (if arg
        (call-interactively 'direx:find-directory-other-window)
      (or (ignore-errors
            (direx-project:jump-to-project-root-other-window) t)
          (direx:jump-to-directory-other-window))))

  (defun direx:my-append-buffer-name-hint ()
    "Append a auxiliary string to a name of direx buffer."
    (when (eq major-mode 'direx:direx-mode)
      (let* ((dir default-directory)
             (drive (if (and (winp) ;; Windows の場合はドライブレターを追加
                             (string-match "^\\([a-zA-Z]:\\)/" dir))
                        (match-string 1 dir) "")))
        (rename-buffer (concat (buffer-name) " [" drive "Direx]") t))))
  (add-hook 'direx:direx-mode-hook 'direx:my-append-buffer-name-hint)
  )

#+END_SRC
** multiple-cursor
#+BEGIN_SRC emacs-lisp +n
(use-package multiple-cursors :defer t
  :bind (("C->" . mc/mark-next-like-this)
         ("C-<" . mc/mark-previous-like-this)
         ("M-R" . mc/mark-all-dwim))
  :custom
  (mc/list-file (my-locate-user-tmp-file ".mc-lists.el"))
  )
#+END_SRC
** web-mode.el
- [[http://web-mode.org/][web-mode.el - HTML template editing (PHP/JSP/ASP) for Emacs]]
package.el からインストール．

`font-lock-mode' が有効だとハイライトされないみたい．whitespace-mode とかと競
合してしまうようだ．
#+BEGIN_SRC emacs-lisp +n
(use-package web-mode :defer t
  :mode (("\\.phtml\\'"     . web-mode)
         ("\\.tpl\\.php\\'" . web-mode)
         ("\\.jsp\\'"       . web-mode)
         ("\\.as[cp]x\\'"   . web-mode)
         ("\\.erb\\'"       . web-mode)
         ("\\.mustache\\'"  . web-mode)
         ("\\.djhtml\\'"    . web-mode)
         ("\\.html?\\'"     . web-mode)
         ("\\.gsp\\'"       . web-mode))
  :init
  ;; web-modeをmagic-mode-alistで起動する
  (dolist (cns magic-fallback-mode-alist)
    (when (eq (cdr cns) 'html-mode)
      (add-to-list 'magic-mode-alist (cons (car cns) 'web-mode))))
  :config
  (bind-keys :map web-mode-map
             ("C-c C-c" . web-mode-navigate)
             ("C-c C-s" . web-mode-surround))

  ;; indent
  (setq web-mode-markup-indent-offset 2
        web-mode-css-indent-offset    2)

  ;; eldoc
  (defun web-mode-enable-eldoc ()
    (eldoc-mode 1)
    (setq-local eldoc-documentation-function #'web-mode-dom-xpath))
  (add-hook 'web-mode-hook #'web-mode-enable-eldoc)

  (add-hook 'web-mode-hook 'emmet-mode)
  )
#+END_SRC
** fill-column-indicator
- [[https://github.com/alpaker/Fill-Column-Indicator][alpaker/Fill-Column-Indicator]]
`fill-column' の桁を明示してくれるライブラリ．すばらしい．package.el でインス
トール
#+BEGIN_SRC emacs-lisp +n
;; fill-column-indicator.el
(use-package fill-column-indicator :defer t
  :config
  (setq fci-rule-color "gray")
  (define-globalized-minor-mode global-fci-mode fci-mode turn-on-fci-mode)
  ;(global-fci-mode)
  (add-hook 'mu4e-compose-mode-hook 'turn-on-fci-mode)
  ;(add-hook 'emacs-lisp-mode-hook 'turn-on-fci-mode)
  (define-key my-original-map (kbd "M-f") 'fci-mode)
  )
#+END_SRC
org-mode で有効にするといろいろな動作で重くなる．折りたたみされているのが良く
ない？ org-mode の html エクスポートで，ソースブロックの文末に変な文字が表示
されるのはコレのせいだったようだ．
** hiwin.el
- [[http://d.hatena.ne.jp/ksugita0510/20111223][gnupackの開発メモ]]
非アクティブなウィンドウの背景色を変更する．
#+BEGIN_SRC emacs-lisp +n
(use-package hiwin
  :config
  (set-face-attribute 'hiwin-face nil :background nil) ;; hiwinデフォルトの背景色を無効化
  (face-spec-set 'hiwin-face ;; 非アクティブウィンドウの背景色を設定
                 '((((class color) (background light))
                    :background "gray90")
                   (((class color) (background dark))
                    :background "gray10")))
  ;; magit関連のバッファは背景色を変えない
  (setq hiwin-always-active-buffer-name-regexp
        (concat hiwin-always-active-buffer-name-regexp "\\|magit-\\(revision\\|diff\\):\\|\\*PLANTUML Preview\\*"))
  (hiwin-activate)                            ;; hiwin-modeを有効化
  )
#+END_SRC
** python 関連
*** ac-python.el
- [[http://d.hatena.ne.jp/CortYuming/20111224/p1][Pythonの補完をEmacsでシンプルに最小労力で手早く使えるようにする - 牌語備忘録 - pygo]]
#+BEGIN_SRC emacs-lisp +n
;; (auto-install-from-url "http://chrispoole.com/downloads/ac-python.el")
(use-package ac-python :defer t :disabled t
  :config
  (add-to-list 'ac-modes 'python-mode))
#+END_SRC
** ruby 関連
*** ruby-mode.el
#+BEGIN_SRC emacs-lisp +n
;; ruby-mode
(use-package ruby-mode :defer t
  :config
  (use-package ruby-electric
    :config
    (add-hook 'ruby-mode-hook
              (lambda () (ruby-electric-mode t))))
    (define-key ruby-mode-map (kbd "C-c h") 'anything-rurima)
#+END_SRC
*** RSense
- 公式 [[http://cx4a.org/software/rsense/index.ja.html][RSense - EmacsやVimなどに特化したRubyのための優れた開発援助ツール]]
コード補完，型検査，定義元ジャンプなどができる Ruby のための開発援助ツール．
#+BEGIN_SRC emacs-lisp +n
  ;; rsense.el
  (setq rsense-home (locate-user-emacs-file "site-lisp/rsense-0.3"))
  (setq rsense-rurema-home (expand-file-name "doc/ruby-refm-1.9.2" rsense-home))

  ;; keymap for rsense
  (defvar my-rsense-map (make-sparse-keymap) "Keymap for rsense.")
  (defalias 'my-rsense-prefix my-rsense-map)
  (loop for (command key) in '((rsense-clear "c")
                             (rsense-close-project "C")
                             (rsense-complete "TAB")
                             (rsense-exit "q")
                             (rsense-jump-to-definition "j")
                             (rsense-open-project "o")
                             (rsense-type-help "t")
                             (rsense-version "v")
                             (rsense-where-is "w"))
      do (define-key my-rsense-map (read-kbd-macro key) command))
  ;; (with-eval-after-load 'key-chord
  ;;   (key-chord-define ruby-mode-map "rs" 'my-rsense-prefix))
  (define-key ruby-mode-map (kbd "C-c i") 'my-rsense-prefix)

  (with-eval-after-load 'guide-key
    (defun guide-key/my-hook-function-for-rsense ()
      (dolist (key '("C-c" "C-c i"))
        (guide-key/add-local-guide-key-sequence key))
      (guide-key/add-local-highlight-command-regexp "rsense-"))
    (add-hook 'ruby-mode-hook 'guide-key/my-hook-function-for-rsense))

  (use-package rsense
    :config
    (add-hook 'ruby-mode-hook
              (lambda ()
                ;; rsense の ac-source を追加
                (add-to-list 'ac-sources 'ac-source-rsense-method)
                (add-to-list 'ac-sources 'ac-source-rsense-constant))))
#+END_SRC
*** key-combo の設定
#+BEGIN_SRC emacs-lisp +n
  ;; (with-eval-after-load 'key-combo
  ;;   (key-combo-define ruby-mode-map (kbd "=") '(" = " " == " " === "))
  ;;   (key-combo-define ruby-mode-map (kbd "=~") " =~ ")
  ;;   ;; (key-combo-define ruby-mode-map (kbd "=>") " => ")
  ;;   ;; (key-combo-define ruby-mode-map (kbd "<=") " <= ")
  ;;   (key-combo-define ruby-mode-map (kbd ",") ", ")
  ;;   (key-combo-define ruby-mode-map (kbd "!=") " != ")
  ;;   (key-combo-define ruby-mode-map (kbd "<") '(" < " " << " " <= "))
  ;;   (key-combo-define ruby-mode-map (kbd ">") '(" > " " >> " " >= "))
  ;;   (key-combo-define ruby-mode-map (kbd "/") '("/" "/`!!'/")) ; どうも ac-source-filename のオムニ補完と競合してるっぽい
  ;;   )
  ;; (add-hook 'ruby-mode-hook (lambda () (key-combo-mode t)))
  )
#+END_SRC
*** 参考URL
- Rsense の導入の仕方など [[http://mitukiii.jp/2010/10/29/install-rsense-to-mac/][mitukiii.jp | Emacs/Vimなどに特化したRubyのための開発補助ツー
  ルRsenseをMac に入れてみた]]
- かなり多くの ruby 関連の設定が書いてある [[http://d.hatena.ne.jp/eiel/20101106][Rubyに関するEmacsの設定を晒してみ
  る - そんなこと覚えてるわけがない。]]
** hl-line+.el
- [[http://d.hatena.ne.jp/khiker/20070409/emacs_hl_line][現在行のハイライト - とりあえず暇だったし何となく始めたブログ]]
カーソルのある行をハイライトする．hl-line+ は hl-line を拡張する．オーバーレ
イの優先度を設定したり，アイドル時のみハイライトしたりできる．
#+BEGIN_SRC emacs-lisp +n
(use-package hl-line+ :defer t  ; hl-line is also loaded
  :ensure nil
  :config
  (global-hl-line-mode 1)
  (defface my-hl-line-face
    '((((class color) (background dark))  ; カラーかつ, 背景が dark ならば,
       (:background "gray10" t))          ; 背景を黒に.
      (((class color) (background light)) ; カラーかつ, 背景が light ならば,
       (:background "gray90" t))          ; 背景を ForestGreen に.
      (t (:bold t)))
    "hl-line's my face")
  (setq hl-line-face 'my-hl-line-face)
  (setq hl-line-overlay-priority 1)  ; ハイライトの優先度．個人的には低くしたい
  )
#+END_SRC
** [[https://github.com/justbur/emacs-which-key][which-key]]
guide-keyよりだいぶ高機能かつ柔軟になっている。いいね。
#+BEGIN_SRC emacs-lisp +n
(use-package which-key
  :config
  (which-key-setup-side-window-right)
  (setq which-key-idle-delay 0.5
        which-key-separator "→"
        which-key-side-window-max-width 0.5)
  (which-key-mode)
  )
#+END_SRC
** guide-key.el
キーバインドを自動的に表示
#+BEGIN_SRC emacs-lisp +n
(use-package guide-key :disabled t
  :config
  (setq-default guide-key/guide-key-sequence
                '("C-c" "C-x v" "C-c p" "C-x RET" "C-x 8"
                  "C-q" "C-x r" "C-S-r" "C-x 4" "C-4" "C-S-a" "C-x 5" "C-5"
                  "<key-chord>"
                  (dired-mode "*")
                  ))
  (setq guide-key/highlight-command-regexp
        '(("^org-table-" . org-table) ("^org-clock-" . org-agenda-clocking)
          ("^org-timer-" . org-agenda-current-time)
          ("^org-toggle-" . org-column-title)
          "^dired-" "^(?org-"))
  ;; (setq guide-key/highlight-command-regexp "rectangle\\|ffap")
  (setq guide-key/popup-window-position 'right
        guide-key/polling-time 0.1
        guide-key/idle-delay 0.3
        guide-key/text-scale-amount -1)
  (setq guide-key/recursive-key-sequence-flag t)
  (guide-key-mode 1)
  (guide-key/key-chord-hack-on)
  )
#+END_SRC
** save-load-path.el
#+BEGIN_SRC emacs-lisp +n
(use-package save-load-path :defer t
  :if (linuxp)
  :config
  (save-load-path-initialize))
#+END_SRC
** wrap-region.el
リージョンを特定文字で囲む
#+BEGIN_SRC emacs-lisp +n
(use-package wrap-region :defer t
  :init
  (add-hook 'prog-mode-hook 'wrap-region-mode)
  (add-hook 'text-mode-hook 'wrap-region-mode)
  :config
  (wrap-region-add-wrapper "`" "'" nil 'lisp-mode)
  (wrap-region-add-wrapper "`" "`" nil 'markdown-mode)
  (wrap-region-add-wrapper "`" "`" nil 'gfm-mode)
  
  )
#+END_SRC
** expand-region.el
- [[https://github.com/magnars/expand-region.el][magnars/expand-region.el]]
#+BEGIN_SRC emacs-lisp +n
(use-package expand-region :defer t
  :init
  (with-eval-after-load 'key-chord
    (key-chord-define-global "@@" 'er/expand-region))
  :bind ("M-@" . er/expand-region)
  )
#+END_SRC
** auto-save-buffers-enhanced.el
アイドル時にファイルを自動保存。auto-save-buffersの機能拡張。
#+BEGIN_SRC emacs-lisp +n
(use-package auto-save-buffers-enhanced
  :config
  (setq auto-save-buffers-enhanced-quiet-save-p t)
  (setq auto-save-buffers-enhanced-save-scratch-buffer-to-file-p t)
  (auto-save-buffers-enhanced t)
  (add-to-list 'auto-save-buffers-enhanced-exclude-regexps "\\[\\*Org Src")
  )
#+END_SRC
** smartrep.el
- [[http://sheephead.homelinux.org/2011/12/19/6930/][連続操作を素敵にするsmartrep.el作った - sheephead]]
連続コマンド入力を支援
#+BEGIN_SRC emacs-lisp +n
(use-package smartrep
  :config
  ;; ミニバッファのエコーバックがうざいので消す
  (defadvice smartrep-read-event-loop (around suppress-echo activate)
    "Suppress echo keystrokes in smartrep."
    (let ((echo-keystrokes 0))
      ad-do-it))

  (smartrep-define-key
      global-map "C-q" '(("[" . (backward-paragraph))
                         ("]" . (forward-paragraph))
                         ("b" . moz-scroll-up)
                         ("f" . moz-scroll-down)
                         ("h" . moz-prev-tab)
                         ("l" . moz-next-tab)
                         ("C-n" . outline-next-visible-heading)
                         ("C-p" . outline-previous-visible-heading)
                         ("C-f" . (outline-forward-same-level 1))
                         ("C-b" . (outline-backward-same-level 1))
                         ("C-u" . outline-up-heading)
                         ("C-/" . winner-undo)))

  (smartrep-define-key
   global-map "C-x" '(("{" . (enlarge-window-horizontally -1))
                      ("}" . (enlarge-window-horizontally 1))))

  (global-set-key (kbd "C-M-v") nil)
  (smartrep-define-key
   global-map "C-M-v" '(("j" . (scroll-other-window 1))
                        ("k" . (scroll-other-window -1))
                        ("J" . (scroll-other-window 4))
                        ("K" . (scroll-other-window -4))
                        ("d" . (scroll-other-window (/ (window-height) 2)))
                        ("u" . (scroll-other-window (- (/ (window-height) 2))))
                        ("f" . scroll-other-window)
                        ("b" . (scroll-other-window '-))
                        ("g" . (beginning-of-buffer-other-window 0))
                        ("G" . (end-of-buffer-other-window 0))))

  (with-eval-after-load 'org
    (smartrep-define-key
        org-mode-map "C-c" '(("C-n" . org-next-visible-heading)
                             ("C-p" . org-previous-visible-heading)
                             ("C-f" . (org-forward-heading-same-level 1))
                             ("C-b" . (org-backward-heading-same-level 1))
                             ("C-u" . outline-up-heading)))
       )

  (with-eval-after-load 'web-mode
    (define-key web-mode-map (kbd "C-c C-n") nil) ; unbind key
    (smartrep-define-key web-mode-map "C-c"
      '(("n" . web-mode-dom-traverse)
        ("p" . web-mode-element-sibling-previous)
        ("f" . web-mode-element-sibling-next)
        ("b" . web-mode-element-sibling-previous)
        ("u" . web-mode-element-parent)
        ("d" . web-mode-element-child)
        ("TAB" . web-mode-fold-or-unfold)
        )))
  )
#+END_SRC
** quickrun.el
ワンタッチでスクリプト実行．marmalade からインストール
#+BEGIN_SRC emacs-lisp +n
(use-package quickrun :defer t
  :bind ("<C-f11>" . quickrun)
  :config
  (quickrun-add-command  "java8"
                         '((:command . "java8")
                           (:compile-only . "javac8 -Werror %o %s")
                           (:exec    . ("javac8 %o %s" "%c %N %a"))
                           (:cmdopt . "-encoding UTF-8")
                           (:remove  . ("%n.class"))
                           (:description . "Compile Java8 file and execute")))

  (defadvice quickrun/use-tempfile-p (after java8 activate)
    "Java8でも一時ファイルを作らないようアドバイス"
    (when (string= (ad-get-arg 0) "java8")
      (setq ad-return-value nil)))
  )
#+END_SRC
** open-junk-file.el
試行錯誤用ファイルを開く．
#+BEGIN_SRC emacs-lisp +n
(use-package open-junk-file :defer t
  :bind ("C-c j" . open-junk-file)
  )
#+END_SRC
** lispxmp.el
式の評価結果を注釈する．
#+BEGIN_SRC emacs-lisp +n
;;; (auto-install-from-emacswiki "lispxmp.el")
(use-package lispxmp :defer t
  :bind ("C-c C-d" . lispxmp)
  )
#+END_SRC
** paredit.el
括弧の対応を保持して編集．
#+BEGIN_SRC emacs-lisp +n
;;; (auto-install-from-url "http://mumble.net/~campbell/emacs/paredit.el")
(use-package paredit :disabled t
  :config
  (add-hook 'emacs-lisp-mode-hook 'enable-paredit-mode)
  (add-hook 'lisp-interaction-mode-hook 'enable-paredit-mode)
  (add-hook 'lisp-mode-hook 'enable-paredit-mode)
  (add-hook 'ielm-mode-hook 'enable-paredit-mode)
  )
#+END_SRC
paredit.el をつけておくとファイルを開くときにメジャーモードの判定に失敗したり
する．何でかは分からんが不便なのでコメントアウトしとく
** undo-tree.el
- [[http://www.emacswiki.org/emacs/UndoTree][EmacsWiki: Undo Tree]]
編集履歴を木構造で視覚的に表示しアンドゥできる．
#+BEGIN_SRC emacs-lisp +n
(use-package undo-tree
  :config
  (global-undo-tree-mode)
  (setq-default undo-tree-visualizer-timestamps t) ; display timestamp in visualizer
  ;(define-key undo-tree-map (kbd "C-g") 'undo-tree-visualizer-quit)  ; unable to bind "C-g"?
  ;; bind redo to "C-_" because default bind "C-?" is unavailable in CUI
  ;(define-key undo-tree-map (kbd "C-_") 'undo-tree-redo)
  ;; "C-/" is translated "C-_" in CUI. So, I can't use undo-tree-undo on above setting.
  )
#+END_SRC
** magit.el
Emacs から git を操作するライブラリ．
#+BEGIN_SRC emacs-lisp +n
;; magit.el
(use-package magit :defer t
  :if (executable-find "git")
  :config
  (bind-key "M-p" nil magit-status-mode-map)
  (bind-key "M-n" nil magit-status-mode-map)
  (bind-key ";" #'magit-margin-popup magit-log-mode-map)
  ;; WindowsからTRAMP経由でのmagitを使えるようにする設定
  (setq magit-git-executable "git")
  (setq magit-git-environment (list (format "INSIDE_EMACS=%s,magit" emacs-version)))
  (setq magit-need-cygwin-noglob nil)
  ;; diffを表示しているときに文字単位での変更箇所も強調表示する
  (setq magit-diff-refine-hunk t)
  (set-variable 'magit-log-margin '(nil age magit-log-margin-width t 18)) ; ログの右マージンを初期表表示しない
  ;; 独自アクション
  (defun magit-commit-amend-noedit (&optional args)
    "Amend the last commit without changing a message.
\n(git commit --amend --no-edit ARGS)"
    (interactive (list (magit-commit-arguments)))
    (magit-commit-amend-assert)
    (magit-run-git-with-editor "commit" "--amend" "--no-edit" args))
  (if (featurep 'transient)  ; transient or magit-popup
      (transient-append-suffix 'magit-commit 'magit-commit-amend ; Amendの後ろに追加
        '("n" "Amend --no-edit" magit-commit-amend-noedit))
    (magit-define-popup-action 'magit-commit-popup
                               ?n "Amend --no-edit" 'magit-commit-amend-noedit)
    )
  ;; `markdown-mode' でコミットメッセージを編集する
  (when (locate-library "markdown-mode")
    (setq git-commit-major-mode 'markdown-mode))
#+END_SRC
*** キーバインド
#+BEGIN_SRC emacs-lisp +n
  (loop for i from 1 to 4
        do
        ;; M-digit を開放
        (define-key magit-status-mode-map (read-kbd-macro (format "M-%d" i)) nil)
        ;; M-digit の代わりに digit を使う
        (define-key magit-status-mode-map (number-to-string i)
          (intern (format "magit-show-level-%d-all" i))))
#+END_SRC
*** 自作関数
#+BEGIN_SRC emacs-lisp +n
  (defadvice magit-revision-refresh-buffer (after show-diff activate)
    "Automatically diff of all hunks in `magit-reivision-mode'."
    (magit-section-show-level-3-all))

  (defun magit-my-commit-current-file ()
    "Commit changes in acurrent file.
  Changes are displayed in `magit-log-edit-buffer'."
    (interactive)
    (let ((file (buffer-file-name)))
      (when file
        (magit-run-git "add" file)
        (magit-log-edit)
        (shell-command (format "%s diff --cached %s | sed 's/^/# /'"
                               magit-git-executable file)
                       (current-buffer))
        (insert "\n")
        (goto-char (point-min)))))

  (defun magit-view-item-other-window ()
    "View item in other window."
    (interactive)
    (magit-visit-item t)
    (other-window -1))
  (define-key magit-mode-map (kbd "C-o") 'magit-view-item-other-window)

  ;; (defun my-magit-apply-file-header-face ()
  ;;   "Apply magit-diff-file-header."
  ;;   (interactive)
  ;;   (goto-char (point-min))
  ;;   (while (re-search-forward "^diff --git" nil t)
  ;;     (let ((min-pt (match-beginning 0)))
  ;;       (when (re-search-forward "^\+\+\+.*$" nil t)
  ;;         (add-text-properties min-pt (match-end 0)
  ;;                              '(face magit-diff-file-header))))))
  ;; (add-hook 'magit-mode-hook 'my-magit-apply-file-header-face t)
  ;; あんま上手くいかんねー
#+END_SRC
*** magit-key-mode時にデフォルトでオンにするオプション
- [[http://emacs.stackexchange.com/questions/3289/can-i-have-the-git-log-all-option-be-initially-selected][magit - Can I have the git-log "--all" option be initially selected? - Emacs Stack Exchange]]
- [[elisp:(find-function%20'magit-key-mode-generate)][magit-key-mode.elの `magit-key-mode-generate']] あたりを参考にした
#+BEGIN_SRC emacs-lisp +n
  (defvar magit-key-mode-my-default-switches
     '((logging "--all") (committing "--verbose")))
  (defun magit-key-mode-my-switch-advice (group switches)
    (eval
     `(defadvice ,(intern (concat "magit-key-mode-popup-" (symbol-name group)))
          (after switch-advice activate)
        ,(format "Toggle default switches for %S menu" group)
        (dolist (s (list ,@switches))
          (magit-key-mode-toggle-option (quote ,group) s))
        )))
  (mapc (lambda (g)
          (magit-key-mode-my-switch-advice (car g) (cdr g)))
        magit-key-mode-my-default-switches)
#+END_SRC
*** フック
#+BEGIN_SRC emacs-lisp +n
  (add-hook 'magit-log-edit-mode-hook
            (lambda ()
              (set-fill-column 72)))
  )
#+END_SRC
** col-highlight.el
hilight current column.
#+BEGIN_SRC emacs-lisp +n
;;; (auto-install-from-url "http://www.emacswiki.org/cgi-bin/wiki/download/vline.el")
;;; (auto-install-from-url "http://www.emacswiki.org/emacs/download/col-highlight.el")
(use-package col-highlight :defer t
  :ensure nil
  :config
  ;(column-highlight-mode 1)
  ;; 常に on にしとくのはちょっと重すぎるのでコメントアウト
  (custom-set-faces
   '(col-highlight ((t (:background "gray10")))))
  (setq col-highlight-period 4)
  (global-set-key (kbd "C-+") 'flash-column-highlight)
  (define-key my-original-map (kbd "C-c") 'column-highlight-mode)
  )
#+END_SRC
** yasnippet.el
テンプレート挿入ライブラリ．柔軟性が高すぎて設定に困る．
#+BEGIN_SRC emacs-lisp +n
;;;; yasnippet.el
(use-package yasnippet :defer t
  :commands (yas-expand yas-minor-mode helm-c-yas-complete)
  :mode "\\.\\(ya\\)?snippet\\'"
  :init
  (bind-key "C-e" 'yas-expand my-original-map)
  :config
  ;; キーバインドは以下を参考にした
  ;; http://emacs.g.hatena.ne.jp/Shinnya/20100805/1281034504
  (setq yas-trigger-key (kbd "<C-tab>"))      ; TAB だと auto-complete とかぶるので変更
  (setq yas-next-field-key (kbd "<C-tab>"))   ; これが <C-tab> にならんなぁ
  ;; (setq yas/prev-field-key "<S-tab>")
  ;; (define-key yas/minor-mode-map (kbd "C-<tab>") 'yas/expand)
  (setq yas-wrap-around-region t)
  (yas-load-directory (locate-user-emacs-file "snippets"))

  (setq yas-prompt-functions '(yas-completing-prompt))
  ;; original function
  (defun yas-c-format-count (str)
    "Return comma according to c format string"
    (save-match-data
      (set-match-data nil)
      (let ((result ""))
        (when (string-match "%[^%]" str)
          (setq result ", ")
          (while (string-match "%[^%]" str (match-end 0))
            (setq result (concat result ", "))))
        result)))
;;; yasnippet を helm で操作
  (with-eval-after-load 'helm
     (use-package helm-c-yasnippet
       :config
       (setq helm-c-yas-space-match-any-greedy t) ; スペース区切りで絞り込めるようにする デフォルトは nil
       (define-key mode-specific-map (kbd "y") 'helm-yas-complete)
       ))
  (yas-global-mode 1)
  )
#+END_SRC
** cygwin-mount.el
cygwin のパスを使えるようにする．
#+BEGIN_SRC emacs-lisp +n
;;; (auto-install-from-url "http://home.avvanta.com/~offby1/cygwin-mount/cygwin-mount.el")
(use-package cygwin-mount
  :ensure nil
  :if (and (winp) cygwinp)
  :config
  (cygwin-mount-activate))
#+END_SRC
** zlc.el
ミニバッファでの補完を zsh ライクにする．
#+BEGIN_SRC emacs-lisp +n
;;; (auto-install-from-url "https://github.com/mooz/emacs-zlc/raw/master/zlc.el")
(use-package zlc
  :config
  (let ((map minibuffer-local-map))
    ;; like menu select
    (define-key map (kbd "<down>")  'zlc-select-next-vertical)
    (define-key map (kbd "<up>")    'zlc-select-previous-vertical)
    (define-key map (kbd "<right>") 'zlc-select-next)
    (define-key map (kbd "<left>")  'zlc-select-previous)

    (define-key map (kbd "H-n")  'zlc-select-next-vertical)
    (define-key map (kbd "H-p")    'zlc-select-previous-vertical)
    (define-key map (kbd "H-f") 'zlc-select-next)
    (define-key map (kbd "H-b")  'zlc-select-previous)
    ))
#+END_SRC
** moz.el
mozrepl を通して firefox を操作する
#+BEGIN_SRC emacs-lisp +n
(use-package moz :defer t)
#+END_SRC
*** [[https://github.com/RenWenshan/emacs-moz-controller][moz-controller.el]]
mozreplを使ったコマンドもろもろを定義しているライブラリ。自作コマンドが不要になった。
#+BEGIN_SRC emacs-lisp +n
(use-package moz-controller :defer t
  :commands (moz-controller-page-refresh moz-controller-page-down
             moz-controller-page-up moz-controller-tab-close
             moz-controller-zoom-in moz-controller-zoom-out
             moz-controller-zoom-reset moz-controller-tab-previous
             moz-controller-tab-next moz-controller-view-page-source
             moz-controller-get-current-url toggle-moz-repl-auto-refresh)
  :config
  (defun toggle-moz-repl-auto-refresh (&optional buffer)
    "Automatically refresh a firefox when a markdown file has changed."
    (interactive)
    (with-current-buffer (or buffer (current-buffer))
      (if (memq 'moz-controller-page-refresh after-save-hook)
          (progn
            (remove-hook 'after-save-hook 'moz-controller-page-refresh :local)
            (message "Disable auto refresh"))
        (add-hook 'after-save-hook 'moz-controller-page-refresh nil :local)
        (message "Enable auto refresh"))))
  )
#+END_SRC
** concurrent.el
非同期処理フレームワーク．
#+BEGIN_SRC emacs-lisp +n
;;; (auto-install-from-url "https://github.com/kiwanami/emacs-deferred/raw/master/concurrent.el")
(use-package concurrent :defer t)
#+END_SRC
** deferred.el
非同期処理ライブラリ．
#+BEGIN_SRC emacs-lisp +n
;;; (auto-install-from-url "http://github.com/kiwanami/emacs-deferred/raw/master/deferred.el")
(use-package deferred :defer t)
#+END_SRC
** helm.el
インクリメンタルな絞り込みインターフェース．
#+BEGIN_SRC emacs-lisp +n
(use-package helm-config :defer 3
  :ensure helm
  :config
  (helm-mode 1)

  (use-package helm-descbinds
    :config
    (helm-descbinds-install))

  (setq helm-idle-delay 0.1)
  (setq helm-input-idle-delay 0.1)
  (setq helm-split-window-default-side 'right) ; helm バッファのデフォルト位置
  ;(define-key helm-find-files-map (kbd "C-h") 'delete-backward-char)

  (global-set-key (kbd "M-x") 'helm-M-x)
  (define-key ctl-x-map (kbd "C-f") 'helm-find-files)
  (setq helm-ff-transformer-show-only-basename t) ; basename のみ表示
  (define-key helm-command-map (kbd "o") 'helm-occur)
  (define-key helm-command-map (kbd "g") 'helm-do-grep)
  (use-package helm-git-grep
    :config
    (define-key helm-command-map "G" 'helm-git-grep))
  (with-eval-after-load 'key-chord
     (defalias 'helm-command-prefix helm-command-map)
     (key-chord-define-global (kbd ":h") 'helm-command-prefix))

  ;; agrep-goto でアウトラインを開くアドバイス
  ;(defadvice agrep-goto (after org-reveal activate)
  ;   (when (eq major-mode 'org-mode)
  ;      (org-reveal))
  ;   (recenter))
  ;; ミニバッファの履歴を helm で絞込みする
  (define-key minibuffer-local-map (kbd "C-r") 'helm-minibuffer-history)

  ;; prefix で候補を選択可能にする
  (setq helm-enable-shortcuts t)   ; t だと C-number で選択
  ;(define-key helm-map "@" 'helm-select-with-prefix-shortcut)

  ;; for filelist
  ;; (when (linuxp)
  ;;   (setq helm-grep-candidates-fast-directory-regexp "^/tmp")
  ;;   (setq helm-c-filelist-file-name "/tmp/all.filelist"))
  ;; どうも grep 上手くいかない．all.filelist が大きすぎか？
  ;; よし，linux なら locate 使えるので helm-for-files でいいか．current-dir+ も候補に入るし
  (define-key mode-specific-map (kbd "r") 'helm-for-files) ; recentfile 的に使いたい

  ;; helm-show-kill-ring
  (global-set-key (kbd "M-y") 'helm-show-kill-ring)
  (setq helm-kill-ring-threshold 4) ; this variable defines minimum length of strings to show

  ;;;; external elisp

  ;; helm-font-families
  ;; http://d.hatena.ne.jp/mooz/20110320/p1
  (defun helm-font-families ()
    "Preconfigured `helm' for font family."
    (interactive)
    (flet ((helm-mp-highlight-match () nil))
      (helm-other-buffer
       '(helm-c-source-font-families)
       "*helm font families*")))

  (defun helm-font-families-create-buffer ()
    (with-current-buffer
        (get-buffer-create "*Fonts*")
      (loop for family in (sort (delete-duplicates (font-family-list)) 'string<)
            do (insert
                (propertize (concat family "\n")
                            'font-lock-face
                            (list :family family :height 2.0 :weight 'bold))))
      (font-lock-mode 1)))

  (defvar helm-c-source-font-families
        '((name . "Fonts")
          (init lambda ()
                (unless (helm-candidate-buffer)
                  (save-window-excursion
                    (helm-font-families-create-buffer))
                  (helm-candidate-buffer
                   (get-buffer "*Fonts*"))))
          (candidates-in-buffer)
          (get-line . buffer-substring)
          (action
           ("Copy Name" lambda
            (candidate)
            (kill-new candidate))
           ("Insert Name" lambda
            (candidate)
            (with-current-buffer helm-current-buffer
              (insert candidate))))))

  ;;; helm-orgcard.el
  ;;; (auto-install-from-url "https://raw.github.com/gist/1345100/332610ed43c0c310be3281280285fc41b3d4cbdd/helm-orgcard.el")
  ;;; Org-mode のリファレンスカードを使って機能検索 http://d.hatena.ne.jp/kiwanami/20111109/1320857773
  (use-package helm-orgcard)

  ;; helm-bibtex
  ;; (auto-install-from-url "https://raw.github.com/gist/1523216/b8060f8c0792988e862a42f27a18e1d4d35d965d/helm-bibtex.el")
  ;; http://d.hatena.ne.jp/k6ky/20111227/1324987106
  (use-package helm-bibtex
    :config
    (defun helm-bibtex-cite ()
      "Helm command to cite bibliography."
      (interactive)
      (helm-other-buffer
       '(helm-c-source-bibtex)
       "*helm bibtex:")))
#+END_SRC
*** シンプルなバッファ移動
#+BEGIN_SRC emacs-lisp +n
(defvar helm-c-source-simple-buffers-list
  '((name . "Simple Buffer List")
    (candidates . (lambda () (mapcar 'buffer-name (buffer-list))))
    (action . switch-to-buffer)))

(defun helm-simple-buffers-list ()
  (interactive)
  (helm :sources helm-c-source-simple-buffers-list
        :buffer  "*helm-simple-buffers-list*"))
(define-key ctl-x-map (kbd "b") 'helm-simple-buffers-list)
#+END_SRC
*** helm-c-apropos の persistent-action を変更
helm-c-apropos は複数の関数による情報源でできているので，それぞれの persistent-action
を defadvice で変更する．helm-c-describe-face が定義されていなかったので，自分で書いた．
#+BEGIN_SRC emacs-lisp +n
  (defadvice helm-c-source-emacs-commands (after change-persisten-action activate)
    "Change a persistent action of helm source"
    (let ((source ad-return-value)
          (action 'helm-c-describe-function)
          (help "Describe function"))
      (setcdr (assq 'persistent-action source) action)
      (setcdr (assq 'persistent-help source) help)
      (setq ad-return-balue source)))

  (defadvice helm-c-source-emacs-functions (after change-persisten-action activate)
    "Change a persistent action of helm source"
    (let ((source ad-return-value)
          (action 'helm-c-describe-function)
          (help "Describe function"))
      (setcdr (assq 'persistent-action source) action)
      (setcdr (assq 'persistent-help source) help)
      (setq ad-return-balue source)))

  (defadvice helm-c-source-emacs-variables (after change-persisten-action activate)
    "Change a persistent action of helm source"
    (let ((source ad-return-value)
          (action 'helm-c-describe-variable)
          (help "Describe variable"))
      (setcdr (assq 'persistent-action source) action)
      (setcdr (assq 'persistent-help source) help)
      (setq ad-return-balue source)))

  (defadvice helm-c-source-emacs-faces (after change-persisten-action activate)
    "Change a persistent action of helm source"
    (let ((source ad-return-value)
          (action 'helm-c-describe-face)
          (help "Describe face"))
      (setcdr (assq 'persistent-action source) action)
      (setcdr (assq 'persistent-help source) help)
      (setq ad-return-balue source)))

  (defun helm-c-describe-face (face)
    "FACE is symbol or string."
    (describe-face (helm-c-symbolify face)))
#+END_SRC
*** helm-ring.el
mark-ring が helm でたどれる．mark がよくわからなくなった時に使える．
#+BEGIN_SRC emacs-lisp +n
  (use-package helm-ring
    :ensure helm
    :config
    (push '(migemo) helm-source-mark-ring)
    (push '(migemo) helm-source-global-mark-ring)
    (define-key helm-command-map (kbd "SPC") 'helm-all-mark-rings))
#+END_SRC
*** helm-ag
#+BEGIN_SRC emacs-lisp +n
  (use-package helm-ag)
#+END_SRC
*** 最後のカッコ
#+BEGIN_SRC emacs-lisp +n
  )
#+END_SRC
*** helm-swoop
#+BEGIN_SRC emacs-lisp +n
(use-package helm-swoop :defer t
  :init
  (with-eval-after-load 'helm
    (bind-key "s" 'helm-swoop helm-command-map))
  :config
  (setq helm-swoop-split-direction 'split-window-horizontally) ; ウィンドウ分割方向
  )
#+END_SRC
** helm-locate
#+BEGIN_SRC emacs-lisp +n
(use-package helm-locate :defer t
  :ensure helm
  :if (executable-find "locate")
  :config
  (setq helm-locate-command "locate %s -e -A %s"))
#+END_SRC
** color-moccur.el
強化版 occur．moccur をもとに改造したらしい．
#+BEGIN_SRC emacs-lisp +n
;;; (auto-install-from-url "http://www.bookshelf.jp/elc/color-moccur.el")
(use-package color-moccur :defer t
  :bind ("M-s o" . occur-by-moccur)
  :config
  (when (executable-find "cmigemo")
    (setq moccur-use-migemo t))           ; 検索に migemo を使う
  (setq moccur-split-word t)              ; 複数の単語で検索できる
  (with-eval-after-load 'helm
    ;; helm-occurからmoccurを発動する
    (defun occur-from-helm-occur ()
      "Call `occur-by-moccur' from `helm' content."
      (interactive)
      (helm-run-after-quit 'occur-by-moccur helm-input t))
    (define-key helm-map (kbd "C-c C-a") 'occur-from-helm-occur))
  ; moccur-edit
  ; (auto-install-from-url "http://www.bookshelf.jp/elc/moccur-edit.el")
  (use-package moccur-edit))
#+END_SRC
** key-chord.el
キーボード同時押しでコマンドを実行する．
#+BEGIN_SRC emacs-lisp +n
;;; (auto-install-from-emacswiki "key-chord.el")
(use-package key-chord
  :config
  (setq key-chord-two-keys-delay 0.05)
  (setq key-chord-one-keys-delay 0.05)
  (key-chord-mode 1)
  (key-chord-define global-map "nb" 'helm-buffers-list)
  (key-chord-define global-map "jk" 'view-mode)
  (key-chord-define global-map "df" 'describe-function)
  (key-chord-define global-map "dv" 'describe-variable)
  (key-chord-define global-map "dk" 'describe-key)
  (key-chord-define global-map "db" 'describe-bindings)
  (key-chord-define global-map "dm" 'describe-mode)
  (key-chord-define global-map "AA" 'helm-apropos)
  (key-chord-define global-map ":c" 'org-capture)
  (key-chord-define global-map "hl" 'global-hl-line-mode)
  (key-chord-define global-map "gs" 'magit-status)
  (key-chord-define global-map "kb" '(lambda () (interactive) (kill-buffer)))
  (key-chord-define global-map "@0" 'delete-window)
  (key-chord-define global-map "@1" 'delete-other-windows)
  (key-chord-define global-map "@2" 'split-window-vertically)
  (key-chord-define global-map "@3" 'split-window-horizontally)
  (key-chord-define global-map "@4" 'ctl-x-4-prefix)
  (key-chord-define global-map "@5" 'ctl-x-5-prefix)
  (key-chord-define global-map "@k" '(lambda () (interactive)
                                       (kill-buffer)
                                       (delete-window)))
  )
#+END_SRC
** popwin.el
- [[https://github.com/m2ym/popwin-el][m2ym/popwin-el]]
ポップアップウィンドウインターフェースを提供．
#+BEGIN_SRC emacs-lisp +n
(use-package popwin :defer t
  :config
  (setq display-buffer-function 'popwin:display-buffer)
  ;(setq special-display-function 'popwin:special-display-popup-window)   ; display-buffer-function を変更したくない場合こっち
  (setcar (member 'help-mode popwin:special-display-config)
          '(help-mode :position right :width 80))
  (push '("*Buffer List*" :position right :width 0.5) popwin:special-display-config)
  (push '("*nav-help*" :height 0.5) popwin:special-display-config)
  (push '("*Shell Command Output*" :height 0.5) popwin:special-display-config)
  (push '(apropos-mode :position right :width 80) popwin:special-display-config)
  (push '(" *auto-async-byte-compile*" :height 0.4 :position bottom :noselect t) popwin:special-display-config)
  (push '("*One-Key*" :position bottom :noselect t) popwin:special-display-config) ; ウィンドウが多いと表示されるのが遅い気がする。
                                        ; しかも表示されるウィンドウの高さが一定でない気もする。どうしてだろう。
  (push '("*sdic*" :height 0.25 :position top :noselect t) popwin:special-display-config)
  (add-to-list 'popwin:special-display-config '("*quickrun*" :position right :width 85))
  (push '("*latex-math-preview-expression*" :position right :width 0.4 :noselect t) popwin:special-display-config)
  (push '("*MATLAB Help*" :position right :width 0.4) popwin:special-display-config)
  (with-eval-after-load 'key-chord
    (key-chord-define-global ":p" popwin:keymap))
  (add-to-list 'popwin:special-display-config
               '(ert-results-mode :position right :width 80))
  (add-to-list 'popwin:special-display-config
               '(compilation-mode :position right :width 80))
  (setq popwin:special-display-config
        (delete '(" *undo-tree*" :width 60 :position right) popwin:special-display-config))
  ;; *Help* バッファをワンキーで固定
  (define-key help-mode-map (kbd "s") 'popwin:stick-popup-window)
  )
#+END_SRC
** org-mode.el
org-mode 自体は標準であるが非標準elispも必要そうなのでここに書いておく．
#+BEGIN_SRC emacs-lisp +n
(use-package org :defer t
#+END_SRC
*** 一般的設定
#+BEGIN_SRC emacs-lisp +n
  :config
  (define-key org-mode-map (kbd "C-,") nil) ; available cycle-buffer
  (bind-key "M-o M-o" 'org-src-fontify-block org-mode-map)
  (setq org-startup-folded 'content)
  (setq org-startup-truncated nil)
  (setq org-return-follows-link t)
  (setq org-adapt-indentation nil)  ; 見出しのレベルに合わせたインデントは適用しない
  (setq org-src-fontify-natively nil)
  (setq org-default-notes-file (expand-file-name "memo.org" org-directory))
  (setq org-export-copy-to-kill-ring nil) ; don't copy exported content to kill ring
  (setq org-src-preserve-indentation t)
  (setq org-special-ctrl-a/e 'reversed) ; C-aを2回押すとヘッドラインやアイテムの先頭に移動する
  (plist-put org-format-latex-options ':scale 1.8) ; 解像度が大きいので数式の大きさを拡大
  (add-to-list 'org-latex-packages-alist '("" "bm" t))  ;; export 時に bm パッケージをロード
  (add-to-list 'org-file-apps '("\\.docx?\\'" . default))
  (add-to-list 'org-file-apps '("\\.xlsx?\\'" . default))
  (add-to-list 'org-file-apps '("\\.pptx?\\'" . default))
  ;; agenda で参照する org ファイル達
  (setq org-agenda-files `(,org-default-notes-file
                           ,(expand-file-name "task.org" org-directory)
                           ,(expand-file-name "contract.org" org-directory)
                           ,(expand-file-name "english.org" org-directory)
                           ,(expand-file-name "jobhunt.org" org-directory)
                           ,(expand-file-name "LabServer.org" org-directory)
                           ,(expand-file-name "HomeServer.org" org-directory)
                          ))
  ;; リンクが日本語で残念な感じにならないように
  (setq org-activate-links '(date bracket radio tag date footnote angle))
  ;; tag
  (setq org-tag-alist '(("Bookmark" . ?b) ("Job" . ?j)
                        ("Emacs" . ?) ("Research" . ?r) ("Lab" . ?l) ("Misc" . ?m)
                        ("Idea" . ?i) ("Survey" . ?v) ("Server" . ?s) ("Note" . ?n)
                        ("Home" . ?h) ("Firefox" . ?) ("Question" . ?q) ("Vi" . ?)
                        ("Item" . ?t) ("Experiment" . ?e) ("Computer" . ?C) ("Shop" . ?o)
                        ("Apple" . ?A) ("Later" . ?L) ("HTML" . ?H)
                        ("Program" . ?p) ("Tool" . ?T) ("Adobe" . ?) ("Event" . ?E)
                        ("Ubuntu" . ?) ("Debian" . ?) ("Windows" . ?) ("Blog" . ?)
                        ("OrgMode" . ?) ("Lecture" . ?c) ("Linux" . ?) ("Git" . ?G)
                        ("JobHunt" . ?j) ("MATLAB" . ?M) ("TeX" . ?) ("PukiWiki" . ?)
                        ("Ruby" . ?) ("Shell" . ?) ("はてな" . ?)))
  (setq org-todo-keywords '((sequence "TODO(t)" "DOING(i)" "WAIT(w)" "|" "DONE(d)" "DROP(D)" "SOMEDAY(s)")))
  (setq org-log-done nil) ; DONEの時刻を記録 はやっぱやめた
  ;; org-modeのバッファにフォーカスした時にorg-revealする
  ;; もっと適切な単位のhookがありそうだけどわからない
  (add-hook 'window-configuration-change-hook
            #'(lambda () (when (eq major-mode 'org-mode) (org-reveal))))
  ;; org-babelで評価可能なソースブロック設定
  (org-babel-do-load-languages 'org-babel-load-languages
                               '((emacs-lisp . t)
                                 (dot . t)))
#+END_SRC
*** dynamic block
dynamic blockを利用すると動的に更新される文章が書ける。保存時に自動でdynamic blockが更新されるようにする。
#+BEGIN_SRC emacs-lisp +n
  (defun org-my-auto-update-all-dblocks ()
    "Updtae all dynamic blocks in Org-mode buffer."
    (when (eq major-mode 'org-mode)
      (org-update-all-dblocks)))
  ;(add-hook 'before-save-hook 'org-my-auto-update-all-dblocks)
#+END_SRC

名前のついたブロックの内容をそのまま参照するdynamic block。orgのソースブロックを参照する想定。
#+BEGIN_SRC emacs-lisp +n
  (defun org-dblock-write:reference-block (params)
    "Dynamic block to refer to a named block specified :ref-name."
    (let* ((ref-name (plist-get params :ref-name))
           (block-pos (org-babel-find-named-block ref-name)))
      (if block-pos
          (insert (save-excursion
                    (goto-char block-pos)
                    (org-element-property :value (org-element-at-point))))
        (insert (format "Not found a block named \"%s\"" ref-name)))))
#+END_SRC
*** capture 関連
#+BEGIN_SRC emacs-lisp +n
  (setq org-capture-templates
        `(("m" "Today's memo" entry
           (file+function nil my-search-org-headline)
           "** %?\n")
          ("o" "Other day's memo" entry
           (file+function nil (lambda () (my-search-org-headline t)))
           "** %?\n")
          ("b" "Bookmark" entry
           (file+function nil my-search-org-headline)
           "** %?\n%(concat \"   [[\" (jk/moz-url) \"]]\")\n   Entered on %U\n"
           :empty-lines 1)
          ("h" "はてな" entry
           (file+headline "hatena.org" "Draft")
           "** %?" :empty-lines 1)
          ("a" "Article" entry
           (file+headline "article.org" "Draft")
           "** %?\n" :empty-lines 1)
          ("t" "Item" entry
           (file "item.org")
           "* Check %?
:PROPERTIES:
:Name:
:Maker:
:Kind:
:Price:
:Link:
:Image:
:BuyDate:
:END:"
           :empty-lines 1 :prepend t)
          ("i" "Idea" entry
           (file+headline nil "New Ideas")
           "** %?\n   %a\n   %t")))
#+END_SRC
*** publish 関連
#+BEGIN_SRC emacs-lisp +n
  ;(setq org-publish-timestamp-directory
  ;      (locate-user-emacs-file ".org-timestamps/"))
  ;(defvar org-publish-my-web-base-dir (expand-file-name "kaichan" org-directory))
  ;(defvar org-publish-my-web-publishing-dir "/rubner-web:public_html")
  ;(defvar org-publish-kensyu-base-dir (expand-file-name "kensyu" org-directory))
  ;(defvar org-publish-kensyu-publishing-dir "/kensyu:public_html")
  ;(setq org-publish-project-alist
  ;      `(("html"
  ;         :base-directory ,org-publish-my-web-base-dir
  ;         :publishing-directory ,org-publish-my-web-publishing-dir
  ;         :base-extension "org"
  ;         :publishing-function org-publish-org-to-html
  ;         :headline-levels 3
  ;         :section-numbers nil
  ;         :table-of-contents nil
  ;         :recursive t
  ;         :style "<link rel=stylesheet type=\"text/css\" href=\"/~kai/stylesheet.css\" >"
  ;         :exclude-tags ("Draft" "Note")
  ;         :auto-preamble t
  ;         :auto-postamble nil)
  ;        ("images"
  ;         :base-directory ,(expand-file-name "img" org-publish-my-web-base-dir)
  ;         :publishing-directory ,(expand-file-name "img" org-publish-my-web-publishing-dir)
  ;         :base-extension "jpg\\|jpeg\\|png"
  ;         :publishing-function org-publish-attachment)
  ;        ("others"
  ;         :base-directory ,org-publish-my-web-base-dir
  ;         :publishing-directory ,org-publish-my-web-publishing-dir
  ;         :base-extension "css"
  ;         :publishing-function org-publish-attachment
  ;         :recursive t)
  ;        ("kaichan" :components ("html" "images" "others"))
  ;        ("kensyu-html"
  ;         :base-directory ,org-publish-kensyu-base-dir
  ;         :publishing-directory ,org-publish-kensyu-publishing-dir
  ;         :base-extension "org"
  ;         :publishing-function org-publish-org-to-html
  ;         :headline-levels 3
  ;         :section-numbers nil
  ;         :table-of-contents nil
  ;         :recursive t
  ;         :style "<link rel=stylesheet type=\"text/css\" href=\"/~kai/stylesheet.css\" >"
  ;         :html-preamble t
  ;         :html-postamble "<p><span class=\"link\">[<a href=\"/~kai/index.html\">トップへ戻る</a>] [<a href=\"javascript:history.go(-1)\">前に戻る</a>]</span><span class=\"date\">最終更新日: %d</span></p>"
  ;         :exclude "TODO.org"
  ;         :exclude-tags ("Draft" "noexport"))
  ;        ("kensyu-images"
  ;         :base-directory ,(expand-file-name "img" org-publish-kensyu-base-dir)
  ;         :publishing-directory ,(expand-file-name "img" org-publish-kensyu-publishing-dir)
  ;         :base-extension "jpg\\|jpeg\\|png"
  ;         :publishing-function org-publish-attachment)
  ;        ("kensyu-others"
  ;         :base-directory ,org-publish-kensyu-base-dir
  ;         :publishing-directory ,org-publish-kensyu-publishing-dir
  ;         :base-extension "css"
  ;         :publishing-function org-publish-attachment
  ;         :recursive t)
  ;        ("kensyu" :components ("kensyu-html" "kensyu-images" "kensyu-others"))
  ;        ))
#+END_SRC
*** export 関連
#+BEGIN_SRC emacs-lisp +n
  ;; config about latex exporting
  (add-to-list 'org-file-apps '("\\.pdf\\'" . default))
  ;(setq org-export-latex-coding-system 'utf-8-unix)
  (setq org-latex-pdf-process '("latexmk -pdfdvi %f")) ; process for tex->pdf
  ;(setq org-export-latex-date-format "%Y-%m-%d")
  (setq org-latex-default-class "jsarticle")
  (setq org-latex-classes nil)
  (add-to-list 'org-latex-classes
               '("jsarticle"
                 "\\documentclass[a4j]{jsarticle}
\\usepackage[dvipdfmx]{graphicx}"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")
                 ))
  ;; (setcar (member '("" "graphicx" t) org-export-latex-default-packages-alist)
  ;;        '("dvipdfmx" "graphicx" t))   ; add option to graphicx package
  ; default package
  ;; (setcar (member '("" "hyperref" nil) org-export-latex-default-packages-alist)
  ;;         '("dvipdfmx,%\n%colorlinks=true,%\nbookmarks=true,%\nbookmarksnumbered=false,%\nbookmarkstype=toc,%\npdftitle={},%\npdfsubject={},%\npdfauthor={},%\npdfkeywords={},%\n"
  ;;           "hyperref" nil))
  ;; (add-to-list 'org-export-latex-default-packages-alist
  ;;              '("dvipdfmx" "color" nil)
  ;;              t)
  ;; config about beamer export
  (add-to-list 'org-latex-classes
               '("beamer"
                 "\\documentclass[dvipdfmx]{beamer}
\\AtBeginDvi{\\special{pdf:tounicode EUC-UCS2}} % prevent mojibake of bookmark in pdf
\\usetheme{Madrid}
\\setbeamertemplate{navigation symbols}{}
\\renewcommand{\\familydefault}{\\sfdefault}
\\renewcommand{\\kanjifamilydefault}{\\gtdefault}
\\setbeamerfont{title}{size=\\large,series=\\bfseries}
\\setbeamerfont{frametitle}{size=\\large,series=\\bfseries}
\\setbeamertemplate{frametitle}[default][center]
\\usefonttheme{professionalfonts}
\\setbeamertemplate{footline}[frame number]"
                 org-beamer-sectioning
                 ))
  ;; Because completion string of template alist is lower case, upcase it.
  (setq org-structure-template-alist
        (mapcar '(lambda (elm)
                   (cons (car elm)
                         (cons (upcase (nth 1 elm))
                               (cddr elm))))
                org-structure-template-alist))
  ;; key bind
  (global-set-key (kbd "C-c a") 'org-agenda)
  (global-set-key (kbd "C-c l") 'org-store-link)
  (global-set-key (kbd "C-c C-SPC") 'org-mark-ring-goto)

  ;; from info
  (defun org-summary-todo (n-done n-not-done)
    "すべてのサブツリーが終了するとDONEに切り替えます。その他の場合は、TODOに
なります。"
    (let (org-log-done org-log-states)   ; 記録「logging」を終了
      (org-todo (if (= n-not-done 0) "DONE" "TODO"))))
  (add-hook 'org-after-todo-statistics-hook 'org-summary-todo)

  ;; ソースコードブロックの caption を label から div 要素に変更するフィルタ
  ;(defun my-html-filter-src-caption (text backend info)
  ;  "Make a caption of src block div element."
  ;  (when (org-export-derived-backend-p backend 'html)
  ;    (when (string-match "<label class=\"org-src-name\">\\(.+?\\)</label>" text)
  ;      (replace-match "<div class=\"org-src-name\">\\1</div>" t nil text))))
  ;(add-to-list 'org-export-filter-src-block-functions
  ;           'my-html-filter-src-caption)

  ;; external plugin
;;; org-tree-slide.el
;;; (auto-install-from-url "https://raw.github.com/takaxp/org-tree-slide/master/org-tree-slide.el")
  (use-package org-tree-slide :defer t
    :config
    (org-tree-slide-simple-profile)
    (setq org-tree-slide-heading-emphasis t)
    )

  ;; helm source for src block
  (defvar org-src-my-lang-candidates
    '("asymptote" "awk" "calc" "c" "c++" "clojure" "css" "ditaa" "dot" "emacs-lisp"
      "gnuplot" "haskell" "java" "js" "latex" "ledger" "lisp" "lilypond" "matlab"
      "mscgen" "ocaml" "octave" "org" "oz" "perl" "plantuml" "python" "R" "ruby"
      "sass" "scheme" "screen" "sh" "sql" "sqlite")
    "Helm command source for Org-mode src block")
  (defvar helm-c-source-org-src-lang
    '((name . "Available language in Org-mode src block")
      (candidates . org-src-my-lang-candidates)
      (action ("Return as string" . eval)
              ("Return as symbol" . intern)
              ("Insert string" . insert))))

  ;; カーソルのあるサブツリーをエクスポートする
  (defun org-my-export-as-html-current-subtree (&optional arg)
    "Export a current subtree as html.
If specify ARG, the subtree starts ARGth level headline."
    (interactive "p")
    (let ((level (org-current-level)))
      (save-excursion
        (outline-up-heading (- level arg))
        (org-mark-subtree)
        (org-export-as-html-and-open nil))))
  (define-key org-mode-map (kbd "C-c h") 'org-my-export-as-html-current-subtree)
#+END_SRC
*** 自作関数
Excelライクに日付を挿入するコマンド。
#+BEGIN_SRC emacs-lisp +n
  (defun insert-today (&optional date)
    "Insert a string representation of today.
With prefix argument, you can choose a date instead of today."
    (interactive (list
                  (when current-prefix-arg
                   (let ((date-string (org-read-date nil nil nil "Specify date: ")))
                     (apply #'encode-time (org-parse-time-string  date-string))))))
    (insert (format-time-string "%Y/%m/%d" (or date (current-time)))))
  (bind-key "C-;" #'insert-today)
#+END_SRC

#+CAPTION: Windowsの場合は一時的にシェルの名前をnilにするアドバイス
#+BEGIN_SRC emacs-lisp +n
  (defadvice org-open-file (around restore-shell activate)
    "Windowsの場合は一時的にシェルの名前をnilにする"
    (let ((orig-shell-file-name shell-file-name))
      (when (eq system-type 'windows-nt)
        (setq shell-file-name nil))
      ad-do-it
      (setq shell-file-name orig-shell-file-name)))
#+END_SRC
- [[http://stackoverflow.com/questions/11553123/linking-to-files-on-windows-network-share][emacs - Linking to files on Windows Network Share - Stack Overflow]]
UNC Pathへリンクされているファイルを =org-open-at-point= で開こうとすると
: eval: ShellExecute failed: 指定されたファイルが見つかりません。
と怒られる問題への対策。

どうもWindowsで =shell-file-name= をbashにしていると、 =//server/path= という
UNC Pathを開こうとして「ファイルが見つかりません」になるようだ。シェルをnilに
しておくと、 =\\server\path= が（コマンドプロンプトに？）渡されて、正しく開く
ことができる。
*** 他ライブラリ連携
wrap-regionを使って、リージョンを各種markup文字を囲めるようにする。
#+BEGIN_SRC emacs-lisp +n
  (with-eval-after-load 'wrap-region
    (mapc #'(lambda (wrapper)
              (wrap-region-add-wrapper wrapper wrapper nil 'org-mode))
          (mapcar 'car org-emphasis-alist)))
#+END_SRC
*** orgの設定終了
#+BEGIN_SRC emacs-lisp +n
  )
#+END_SRC
*** helm-buffers
#+BEGIN_SRC emacs-lisp +n
(use-package helm-buffers :defer t
  :ensure helm
  :config
  (setq helm-buffer-max-length nil) ; ファイル名の表示幅。nilなら一番長いファイル名に合わせる
  )
#+END_SRC
*** helm-ls-git
git管理下のファイルのhelmソース。
#+BEGIN_SRC emacs-lisp +n
(use-package helm-ls-git :defer t
  :if (executable-find "git")
  :init
  (add-autoload helm-for-files helm-ls-git)
  :config
  ;; `helm-source-ls-git' の初期化のために `helm-source-ls-git' を実行する
  (setq helm-source-ls-git (helm-make-source "Git files" 'helm-ls-git-source
                             :fuzzy-match helm-ls-git-fuzzy-match))
  (setq helm-ls-git-show-abs-or-relative 'relative)
  ;; helm-for-filesでgit管理下のファイルも開く
  (add-to-list 'helm-for-files-preferred-list 'helm-source-ls-git)
  ;; gitリポジトリ外で `helm-ls-git-init' がエラーになるのをアドバイスで回避する
  ;; `helm-ls-git-list-files' が返すnilを `split-string' しようとしてエラーになっているので
  ;; 返り値がnilのの時は空文字にすることで回避できる。
  (defadvice helm-ls-git-list-files (after nil-to-empty activate)
    (unless ad-return-value (setq ad-return-value "")))
  )
#+END_SRC
*** ox-html
#+BEGIN_SRC emacs-lisp +n
(use-package ox-html :defer t
  :ensure org
  :config
  (setq org-html-coding-system 'utf-8)
  (setq org-html-htmlize-output-type 'css)
  ;; `org-html-style-default' を修正
  (when (string-match "pre.src {[^}]*\\(padding-top: 1.2em;\\)[^}]*}" org-html-style-default)
    (setq org-html-style-default
          (replace-match "" t t org-html-style-default 1)))
  )
#+END_SRC
**** srcブロックのクラス名を =SyntaxHighlighter= 準拠のクラス名に変更する
これでなんとかクラス名を変更できた。けど結局 =SyntaxHighlighter= が対応している言語も少なく（Lispがない！）、=SyntaxHighlighter= が対応してない言語のソースブロックがあると =SyntaxHighlighter.all()= の実行時にエラーが発生してしまう。

またEmacsよりもハイライトのカラフルさがなかったのでやっぱりやめた。参考のためにコードは残しておく。

=init.el= の記述は以下のとおり。
#+BEGIN_SRC emacs-lisp +n :tangle no
(with-eval-after-load 'ox-html
  (defun org-html-my-src-syntaxhighlighter-class (data backend info)
    "Replace class for SyntaxHighlighter.

class=\"src src-java\" is replaced into class=\"brush:java\"."
    (when (org-export-derived-backend-p backend 'html)
      (replace-regexp-in-string "class=\"src src-\\([^\"]*\\)\"" "class=\"brush:\\1;\"" data)))
  (add-to-list 'org-export-filter-src-block-functions #'org-html-my-src-syntaxhighlighter-class)
  (setq org-html-htmlize-output-type nil) ; preタグの中身をプレーンテキストで出力するために必要な設定
  )
#+END_SRC

あとはorgファイルの先頭でcssとjsを読み込み、
#+BEGIN_SRC org
#+HTML_HEAD: <link href="https://cdnjs.cloudflare.com/ajax/libs/SyntaxHighlighter/3.0.83/styles/shCoreDefault.min.css" rel="stylesheet" type="text/css" />
#+HTML_HEAD: <link href="https://cdnjs.cloudflare.com/ajax/libs/SyntaxHighlighter/3.0.83/styles/shThemeDefault.min.css" rel="stylesheet" type="text/css" />
#+HTML_HEAD: <script src="https://cdnjs.cloudflare.com/ajax/libs/SyntaxHighlighter/3.0.83/scripts/shCore.min.js" type="text/javascript"></script>
#+HTML_HEAD: <script src="https://cdnjs.cloudflare.com/ajax/libs/SyntaxHighlighter/3.0.83/scripts/shAutoloader.min.js" type="text/javascript"></script>
#+END_SRC

orgファイルの末尾（bodyタグの最後らへんにエクスポートされる場所であれば良いと思われる）にハイライトを有効にするコードを差し込んでおく。
#+BEGIN_SRC org
#+BEGIN_EXPORT HTML
<script type="text/javascript">
  SyntaxHighlighter.autoloader(
    ["bash", "shell", "https://cdnjs.cloudflare.com/ajax/libs/SyntaxHighlighter/3.0.83/scripts/shBrushBash.min.js"],
    ["c-sharp", "csharp", "https://cdnjs.cloudflare.com/ajax/libs/SyntaxHighlighter/3.0.83/scripts/shBrushCSharp.min.js"],
    ["cpp", "c", "https://cdnjs.cloudflare.com/ajax/libs/SyntaxHighlighter/3.0.83/scripts/shBrushCpp.min.js"],
    ["css", "https://cdnjs.cloudflare.com/ajax/libs/SyntaxHighlighter/3.0.83/scripts/shBrushCss.min.js"],
    ["php", "https://cdnjs.cloudflare.com/ajax/libs/SyntaxHighlighter/3.0.83/scripts/shBrushPhp.min.js"],
    ["html", "xml", "xhtml", "https://cdnjs.cloudflare.com/ajax/libs/SyntaxHighlighter/3.0.83/scripts/shBrushXml.min.js"],
    ["js", "jscript", "javascript", "https://cdnjs.cloudflare.com/ajax/libs/SyntaxHighlighter/3.0.83/scripts/shBrushJScript.min.js"],
    ["java", "https://cdnjs.cloudflare.com/ajax/libs/SyntaxHighlighter/3.0.83/scripts/shBrushJava.min.js"],
    ["plain", "https://cdnjs.cloudflare.com/ajax/libs/SyntaxHighlighter/3.0.83/scripts/shBrushPlain.min.js"],
    ["python", "py", "https://cdnjs.cloudflare.com/ajax/libs/SyntaxHighlighter/3.0.83/scripts/shBrushPython.min.js"]
  );
  SyntaxHighlighter.all();
</script>
#+END_EXPORT
#+END_SRC
あとはうまく見えるようにcssを調整すればいい。

- [[http://alexgorbatchev.com/SyntaxHighlighter/][SyntaxHighlighter]]
- [[http://551sornwmc.blog109.fc2.com/blog-entry-380.html][FC2 BlogへSyntaxHighlighter（ソースコードを整形表示する機能）を導入する方法]]
**** 見出しの数字の末尾にピリオドを追加する
#+BEGIN_SRC emacs-lisp +n
(with-eval-after-load 'ox-html
  (defun org-html-headline-period (data backend info)
    "Add a period to the end of headline number."
    (when (org-export-derived-backend-p backend 'html)
      (replace-regexp-in-string "<span class=\"section-number-.*\">.*</span>" "\\&." data)))
  (add-to-list 'org-export-filter-headline-functions #'org-html-headline-period)
  )
#+END_SRC
**** Twitter Bootstrap連携
エクスポートしたHTMLのCSSにTwitter Bootstrapを使うようにしたので、フィルタを使って色んな要素にBootstrapのクラスを付加する。
#+BEGIN_SRC emacs-lisp +n
(with-eval-after-load 'ox-html
  (defun org-export-html-my-bootstrap-container-filter (data backend info)
    "Add \"container\" class into the most outside div."
    (when (org-export-derived-backend-p backend 'html)
      (replace-regexp-in-string
       "<div id=\"content\"" "<div id=\"content\" class=\"container\"" data)))
  (add-to-list 'org-export-filter-final-output-functions #'org-export-html-my-bootstrap-container-filter)
  ;; テーブルのクラスにBootstrapのテーブル用クラスを付与する
  (plist-put org-html-table-default-attributes :class "table table-bordered")
  )
#+END_SRC
**** infoへのリンクをhtmlへのリンクに変換する
#+BEGIN_SRC emacs-lisp +n
(with-eval-after-load 'ox-html
  (defvar org-export-html-my-info-link-alist
    '(("org" . "http://orgmode.org/manual/")
      ("emacs" . "http://www.gnu.org/software/emacs/manual/html_node/emacs/")
      ("elisp" . "http://www.gnu.org/software/emacs/manual/html_node/elisp/")))

  (defun org-export-html-my-info-link-filter (data back-end channel)
    "Convert an info type link to a HTML type link.
The html link is determined from `org-export-html-my-info-link-alist'."
    (let* ((link-plist (nth 0 (cdr (org-find-text-property-in-string :parent data))))
           (link-type (plist-get link-plist :type))
           (link-path (plist-get link-plist :path)))
      (when (and (eq back-end 'html)
                 (string= link-type "info")
                 (string-match "\\([^#]*\\)#\\(.*\\)" link-path))
        (let* ((name (match-string 1 link-path))
               (node (replace-regexp-in-string "%20" "-" (match-string 2 link-path)))
               (man-root (assoc-default name org-export-html-my-info-link-alist))
               (url (concat man-root (if (string= node "Top") "" (concat node ".html")))))
          (replace-regexp-in-string "href=\"\\([^\"]*\\)\"" url data t t 1)))))

  (add-to-list 'org-export-filter-link-functions 'org-export-html-my-info-link-filter))
#+END_SRC
**** HTMLの相対パスを絶対パスに変換する
#+BEGIN_SRC emacs-lisp +n
(with-eval-after-load 'ox-html
  (defun org-export-html-relative-filter (data back-end channel)
    ""
    (let ((regex "\\(?:src\\|href\\)=\"\\([^\"]*\\)\""))
      (while (re-search-forward regex nil t)
        (let ((path (match-string 1)))
          (when (equal (substring path 0 1) "/")
            (replace-match "\&#abc" nil nil nil 1)))))
    )
  (add-to-list 'org-export-filter-link-functions 'org-export-html-relative-filter)
  )
#+END_SRC
**** プロパティでエクスポートを設定を変える
=:html-table-use-header-tags-for-first-column= という変数を、特定のツリー以下で変えたかったので色々いじってみた。

=org-export-backend= 型のoptionsを変えれば良さそうな感じだったけど、結局特定のツリー以下で変更する方法がわからなかった。試行錯誤の結果を残しておく。
#+BEGIN_SRC emacs-lisp :tangle no
(let* ((html-backend (--first (eq (org-export-backend-name it) 'html) org-export-registered-backends))
       (html-options (org-export-backend-options html-backend))
       (opt (alist-get :html-table-use-header-tags-for-first-column html-options)))
  (setf (car opt) "FIRST_COLUMN")
  opt
  )
#+END_SRC
*** babel関連
org-babelを利用するとorg文書中のプログラムを評価してごにょごにょできる。
#+BEGIN_SRC emacs-lisp +n
(use-package ob-core :defer t
  :ensure org
  :config
  (defvar org-my-evaluatable-languages nil
    "Evaluatable languages in org src block without confirmation")
  (defun org-my-confirmation-function (lang body)
    (not (member lang org-my-evaluatable-languages)))
  (setq org-confirm-babel-evaluate #'org-my-confirmation-function)
  ;; babelで評価した後にインライン画像を再描画する。plantumlで画像を生成したときとかね
  (defun my-redisplay-org-inline-images ()
    (when org-inline-image-overlays
      (org-redisplay-inline-images)))
  (add-hook 'org-babel-after-execute-hook #'my-redisplay-org-inline-images)
  )
#+END_SRC
*** org-eldoc
- [[http://orgmode.org/cgit.cgi/org-mode.git/plain/contrib/lisp/org-eldoc.el][org公式のcontribディレクトリ]]からダウンロードしたが、org-plus-contribには無
  いみたいである。なぜだ。
orgドキュメント内で様々なヒントをミニバッファに表示する。
#+BEGIN_SRC emacs-lisp +n
(use-package org-eldoc :defer t
  :ensure org-plus-contrib
  :init
  (add-hook 'org-mode-hook #'eldoc-mode)
  :config
  ;; リンク文字列をeldocで表示する
  (defun org-eldoc-get-link ()
    "Return a raw link if on a link or nil."
    (let* ((ctx (org-element-context))
           (element-type (car ctx))
           (link-props (cadr ctx))
           (type (plist-get link-props :type))
           (path (plist-get link-props :path))
           (application (plist-get link-props :application))
           (search-option (plist-get link-props :search-option)))
      (when (eq element-type 'link)
        (format "%s:%s%s"
                (propertize (concat type (if application (concat "+" application) ""))
                            'face 'font-lock-string-face)
                (propertize (org-link-unescape path) 'face 'org-link)
                (propertize (if search-option (concat "::" search-option) "")
                            'face 'font-lock-type-face)))))
  ;; table-cell
  (defun org-eldoc-clipped-table-cell ()
    "Return a whole string of a clipped cell."
    (let* ((ctx (org-element-context))
           (element-type (car ctx)))
      (when (eq element-type 'table-cell)
        (let* ((props (cadr ctx))
               (beg (plist-get props :contents-begin))
               (end (plist-get props :contents-end)))
          (when (text-property-any beg end 'org-cwidth t)
            (buffer-substring-no-properties beg end))))))
  (defadvice org-eldoc-documentation-function (around get-link activate)
    (setq ad-return-value (or (org-eldoc-get-link)
                              (org-eldoc-clipped-table-cell)
                              ad-do-it)))
  )
#+END_SRC

[[http://orgmode.org/][Org mode for Emacs – Your Life in Plain Text]] ←にカーソルを置いて
=(org-element-context)= を評価したときの出力例。
#+BEGIN_EXAMPLE
(link (:type "http"
       :path "//orgmode.org/"
       :raw-link "http://orgmode.org/"
       :application nil
       :search-option nil
       :begin 178166
       :end 178235
       :contents-begin 178189
       :contents-end 178233
       :post-blank 0
       :parent (paragraph (:begin 178161
                           :end 178236
                           :contents-begin 178161
                           :contents-end 178236
                           :post-blank 0
                           :post-affiliated 178161
                           :parent nil
                           ))))
#+END_EXAMPLE
*** org-mobile
スマホ連携。
- [[https://github.com/matburt/mobileorg-android/wiki][Android実装]]
- [[http://mobileorg.ncogni.to/][iOS実装]]
#+BEGIN_SRC emacs-lisp +n
(use-package org-mobile :defer t :disabled t
  :init
  (run-at-time t (* 60 60) 'org-mobile-push)  ; 60分ごとに org-mobile-push を自動実行
  :config
  (setq org-mobile-directory (expand-file-name "MobileOrg" dropbox-directory))
  (setq org-mobile-inbox-for-pull
        (expand-file-name "mobile-capture.org" org-directory)) ; MobileOrg のキャプチャをかきこむファイル
  (add-to-list 'org-agenda-files org-mobile-inbox-for-pull t)
  ;; org-mobile-files のデフォルトは (org-agenda-files)．item.org を追加
  (add-to-list 'org-mobile-files (expand-file-name "item.org" org-directory))
  (add-to-list 'org-mobile-files (expand-file-name "lecture.org" org-directory))
  )
#+END_SRC
*** org-reveal
orgファイルをreveal.jsのプレゼンテーションにエクスポートする。
#+BEGIN_SRC emacs-lisp +n
(use-package ox-reveal :defer t
  :init
  (setq org-reveal-note-key-char nil)  ; BEGIN_NOTES のショートカットを追加しない
  (add-autoload org-export-dispatch ox-reveal)
  :config
  (setq org-reveal-root "https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.4.1/"
        org-reveal-slide-number t
        org-reveal-history t
        org-reveal-center nil
        org-reveal-margin "0.02"
        org-reveal-transition "slide"
        org-reveal-transition-speed "fast")
  (setq org-reveal-title-slide-template
        "<h2 class=\"title\">%t</h2>
<h3 class=\"author\">%a</h3>
<h3 class=\"email\">%e</h3>
<h3 class=\"date\">%d</h3>")

  (defun org-reveal-open-new-link-filter (data backend info)
    "Add 'target=\"_blank\"' to <a> tag when exported by `ox-reveal'"
    (when (eq backend 'reveal)
      (replace-regexp-in-string "^<a " "<a target=\"_blank\" " data)))
  (add-to-list 'org-export-filter-link-functions 'org-reveal-open-new-link-filter)
  )
#+END_SRC
*** org-printer
org-modeのexport機能を使って印刷する。
#+BEGIN_SRC emacs-lisp +n
(use-package org-printer :defer t :disabled t
  :config
  (setq org-printer-template-file (expand-file-name "template.org" org-directory))
  )
#+END_SRC
*** ox-pandoc
#+BEGIN_SRC emacs-lisp +n
(use-package ox-pandoc :defer t
  :init
  (add-autoload org-export-dispatch ox-pandoc)
  :config
  ;; reveal.js向け設定
  (setcdr (assq ?V org-pandoc-menu-entry)
        '("to revealjs." org-pandoc-export-to-revealjs)) ; エクスポートする関数を変更
  (setq org-pandoc-options-for-revealjs '((variable . "theme:default"))) ; reveal.jsのデフォルトテーマを利用
  )
#+END_SRC

*** org-habit
#+BEGIN_SRC emacs-lisp +n
(with-eval-after-load 'org
  (use-package org-habit :ensure org))
#+END_SRC
*** org-tempo
Org文書で簡単にテンプレートを展開する機能を提供するライブラリ。例えば ~<e~ と入力してTABを押下すると ~#+BEGIN_EXAMPLE～～#+END_EXAMPLE~ に展開できる。高速に入力するのに必要不可欠。

もともとは ~org.el~ に組み込みだった機能が、Orgのバージョン9.2から ~org-tempo.el~ に分離された([[https://orgmode.org/Changes.html][Org mode for Emacs – Release notes]])。同時に ~org-structure-template-alist~ の形式が変わったので、独自にテンプレートを追加していた場合は新しい形式に移行する必要がある。

#+BEGIN_SRC emacs-lisp +n
(use-package org-tempo
  :ensure org
  :after org)
#+END_SRC

ただし [2019-01-28 Mon] 時点では ~<e~ を展開すると ~#+begin_example～～#+end_example~ という小文字で展開される。Org文書の予約語は大文字を推奨されているし、個人的にも大文字のほうが見やすい。が、現状では大文字に展開するようにはできないようだ。

- [[https://www.mail-archive.com/emacs-orgmode@gnu.org/msg122356.html][org-tempo violating org-mode conventions since 9.2]]

上記で議論されていて、大文字、小文字を選ぶオプションを追加しようという話みたいなので、そのうち対応してくれるものと思う。
*** [[https://ox-hugo.scripter.co/][ox-hugo]]
Org文書を[[https://gohugo.io/][Hugo]]形式のMarkdownにエクスポートできる。

#+BEGIN_SRC emacs-lisp +n
(use-package ox-hugo :defer t
  :init
  (add-autoload org-export-dispatch ox-hugo)
  )
#+END_SRC
** google-maps.el
Google Map を表示する．
#+BEGIN_SRC emacs-lisp +n
(use-package google-maps :defer t)
#+END_SRC
** elscreen.el
ウィンドウの分割情報を保持しておく．
#+BEGIN_SRC emacs-lisp +n
(use-package "elscreen"
  :config
  (setq elscreen-display-tab 10)
  (setq elscreen-tab-display-kill-screen nil) ; タブのXを非表示
  (bind-key "M-n" 'elscreen-next)
  (bind-key "M-p" 'elscreen-previous)
  (cl-loop for i from 1 to 10
           do
           (bind-key (format "M-%d" (mod i 10))
                     `(lambda () (interactive) (elscreen-goto ,i))))

  ;; 起動時にスクリーンを10個作っておく
  (defun my-elscreen-startup ()
    (elscreen-start)
    (dotimes (i 9) (elscreen-create)))
  (add-hook 'after-init-hook 'my-elscreen-startup)

  ;; elscreen のタブの並びと数字キーの並びを合わせる
  ;; 既存スクリーンのリストを要求された際、0 番が存在しているかのように偽装する
  (defadvice elscreen-get-screen-list (after my-ad-elscreen-get-screenlist disable)
    (add-to-list 'ad-return-value 0))
  ;; スクリーン生成時に 0 番が作られないようにする
  (defadvice elscreen-create (around my-ad-elscreen-create activate)
    (interactive)
    ;; 0 番が存在しているかのように偽装
    (ad-enable-advice 'elscreen-get-screen-list 'after 'my-ad-elscreen-get-screenlist)
    (ad-activate 'elscreen-get-screen-list)
    ;; 新規スクリーン生成
    ad-do-it
    ;; 偽装解除
    (ad-disable-advice 'elscreen-get-screen-list 'after 'my-ad-elscreen-get-screenlist)
    (ad-activate 'elscreen-get-screen-list))
  ;; スクリーン 1 番を作成し 0 番を削除 (起動時、フレーム生成時用)
  (defun my-elscreen-kill-0 ()
    (when (and (elscreen-one-screen-p)
               (elscreen-screen-live-p 0))
      (elscreen-create)
      (elscreen-kill 0)))
  ;; フレーム生成時のスクリーン番号が 1 番になるように
  (defadvice elscreen-make-frame-confs (after my-ad-elscreen-make-frame-confs activate)
    (let ((selected-frame (selected-frame)))
      (select-frame frame)
      (my-elscreen-kill-0)
      (select-frame selected-frame)))
  ;; 起動直後のスクリーン番号が 1 番になるように
  (add-hook 'after-init-hook 'my-elscreen-kill-0)

  )
#+END_SRC
** php-mode.el
- [[http://sourceforge.net/projects/php-mode/][PHP mode for Emacs | Free Development software downloads at SourceForge.net]]
phpファイルを扱う．
#+BEGIN_SRC emacs-lisp +n
(use-package php-mode :defer t
  :config
  (add-hook 'php-mode-user-hook
            '(lambda ()
               (setq tab-width 2)
               (setq indent-tabs-mode nil))))
#+END_SRC
** sudo-ext.el
- [[http://d.hatena.ne.jp/rubikitch/20101018/sudoext][Emacsの中でsudoする方法 ～これでrootによる操作も楽々～ - (rubikitch loves (Emacs Ruby CUI Books))]]
Emacs 内から sudo をつかう．
#+BEGIN_SRC emacs-lisp +n
;;; (auto-install-from-emacswiki "sudo-ext.el")
(use-package sudo-ext :defer t)
#+END_SRC
** mozc.el
Emacs でMozcを使う．要 mozc-emacs-helper．
#+BEGIN_SRC emacs-lisp +n
;; (use-package mozc)
;; (setq default-input-method "japanese-mozc")
#+END_SRC
** ibus.el
- [[http://www11.atwiki.jp/s-irie/pages/21.html][irie @ ウィキ - ibus.el]]
Emacsでibusを使えるようにする．これで mozc が使える．
#+BEGIN_SRC emacs-lisp +n
(use-package ibus :defer t :disabled t
  :if (linuxp)
  :config
  ;; Turn on ibus-mode automatically after loading .emacs
  (add-hook 'after-init-hook 'ibus-mode-on)
  ;; Use C-SPC for Set Mark command
  (ibus-define-common-key ?\C-\s nil)
  ;; Use C-/ for Undo command
  (ibus-define-common-key ?\C-/ nil)
  ;; Change cursor color depending on IBus status
  (setq ibus-cursor-color '("limegreen" "yellow" "light gray"))
  ;; Use C-\ for ibus-toggle
  (global-set-key (kbd "C-\\") 'ibus-toggle)
  ;; preedit 中に有効にしたいキーバインドは `ibus-define-preedit-key' で追加する
  (ibus-define-preedit-key 'A-v t)
  ;(ibus-define-preedit-key 'C-h t)
  ;; isearch で ibus を無効にする
  (ibus-disable-isearch)
  ;; isearch 中はカーソル形状変更
  (setq ibus-isearch-cursor-type 'hollow)
  )
#+END_SRC
** session.el
- [[http://sourceforge.net/projects/emacs-session/files/][Session Management for Emacs - Browse Files at SourceForge.net]]
Emacsが終了した時のミニバッファ履歴やカーソル位置を保存する．
#+BEGIN_SRC emacs-lisp +n
(use-package session
  :custom
  (session-save-file (my-locate-user-tmp-file ".session"))
  :config
  (add-hook 'after-init-hook 'session-initialize)
  (setq session-globals-include '((kill-ring 50)
                                  (session-file-alist 500 t)
                                  (file-name-history 3000))
        session-globals-max-string 100000000
        history-length t)     ; ミニバッファ履歴リストの長さ制限を無くす
  ;; 最後に保存した位置ではなく，閉じた時の位置を復元する
  (setq session-undo-check -1)
  ;; If you want to use both desktop and session, use:
  (setq desktop-globals-to-save '(desktop-missing-file-warning))
  ;; 定期的に session を保存
  (run-at-time t 60 'session-save-session)
#+END_SRC
*** helmのソースを保存するリストから除外する
#+BEGIN_SRC emacs-lisp +n
  (defadvice session-save-session (before exclude-helm-sources activate)
    "Add helm sources to `session-globals-exclude'."
    (mapc #'(lambda (source) (add-to-list 'session-globals-exclude source))
          (apropos-internal "^helm-\\(?:c-\\)?source-" 'boundp)))
#+END_SRC

=helm-show-kill-ring= を実行しようとすると
: Symbol's value as variable is void: \.\.\.
と怒られて実行できない問題の対策。根本的な原因はhelmのソースを表す変数が
sessionライブラリによって復元されているのが原因。

sessionが保存するファイル(=~/.emacs.d/.session=)には以下のように =\.\.\.= と
いうシンボルが保存されており、上記のエラーが発生する。
: (setq-default helm-c-source-kill-ring '((name . "Kill Ring") (init lambda nil (helm-attrset \.\.\. last-command)) （以下略）
=\.\.\.= という風に保存されてしまう原因そのものはよく分からない。

遅延初期化しているhelmソースが影響を受けそうなので、すべてのhelmソースを除外
するようアドバイスすることで対策する。正規表現で除外する変数名を指定できるよ
うな設定項目があればいいのに。
*** 最後のカッコ
#+BEGIN_SRC emacs-lisp +n
  )
#+END_SRC
** auto-async-byte-compile.el
非同期自動バイトコンパイル．Emacsテクニックバイブル より．
#+BEGIN_SRC emacs-lisp +n
;; (auto-install-from-emacswiki "auto-async-byte-compile.el")
(use-package auto-async-byte-compile
  :config
  ;; 自動バイトコンパイルを無効にするファイル名の正規表現
  (setq auto-async-byte-compile-exclude-files-regexp "diary\\|/junk/")
  (add-hook 'emacs-lisp-mode-hook 'enable-auto-async-byte-compile-mode)
  )
#+END_SRC
** recentf-ext.el
最近開いたファイルを開く．Emacsテクニックバイブルより．
#+BEGIN_SRC emacs-lisp +n
;;; (auto-install-from-emacswiki recentf-ext.el)
(use-package recentf-ext
  :init
  (set-variable 'recentf-auto-cleanup 'never)
  :custom
  (recentf-save-file (my-locate-user-tmp-file "recentf"))
  ;; 最近のファイル3000個を保存する
  (recentf-max-saved-items 3000)
  ;; 最近使ったファイルに加えないファイルを正規表現で指定する
  (recentf-exclude '("/TAGS$" "/var/tmp/" "Temp_ExternalEditor"))
  :config
  ;; automatically save recentf file and supress messages
  ;; http://masutaka.net/chalow/2011-10-30-2.html
  (defvar my-recentf-list-prev nil)

  (defadvice recentf-save-list
    (around no-message activate)
    "If `recentf-list' and previous recentf-list are equal,
do nothing. And suppress the output from `message' and
`write-file' to minibuffer."
    (unless (equal recentf-list my-recentf-list-prev)
      (flet ((message (format-string &rest args)
                      (eval `(format ,format-string ,@args)))
             (write-file (file &optional confirm)
                         (let ((str (buffer-string)))
                           (with-temp-file file
                             (insert str)))))
        ad-do-it
        (setq my-recentf-list-prev recentf-list))))

  (defadvice recentf-cleanup
    (around no-message activate)
    "suppress the output from `message' to minibuffer"
    (flet ((message (format-string &rest args)
                    (eval `(format ,format-string ,@args))))
      ad-do-it))

  (run-with-idle-timer 60 t 'recentf-save-list)
  )
#+END_SRC
** google.el
#+BEGIN_SRC emacs-lisp +n
(use-package google :defer t)
#+END_SRC
** stripe-buffer
#+BEGIN_SRC emacs-lisp +n
(use-package stripe-buffer :defer t
  :init
  (add-hook 'dired-mode-hook 'stripe-buffer-mode)
  :config
  (face-spec-set 'stripe-highlight
                 '((((class color) (background light))
                    :background "#eeeeee")
                   (((class color) (background dark))
                    :background "#111111")))
  )
#+END_SRC
** eldoc.el
引数をミニバッファに表示する．
#+BEGIN_SRC emacs-lisp +n
;; Use Emacs23's eldoc
(use-package eldoc :defer t
  :init
  (add-hook 'emacs-lisp-mode-hook 'eldoc-mode)
  (add-hook 'lisp-interaction-mode-hook 'eldoc-mode)
  (add-hook 'ielm-mode-hook 'eldoc-mode)
  :config
  ;; (auto-install-from-emacswiki "eldoc-extension.el")
  ;;(use-package eldoc-extension)  ; これをつけるとWarningが起こるのでとりあえず
  (setq eldoc-idle-delay 0.05)
  (setq eldoc-echo-area-use-multiline-p t)
  )
;; use c-eldoc
(use-package c-eldoc :defer t
  :config
  (add-hook 'c-mode-hook
            (lambda ()
              (set (make-local-variable 'eldoc-idle-delay) 0.20)
              (c-turn-on-eldoc-mode)
              )))
#+END_SRC
** auto-complete.el
ポップアップメニューで自動補完．
#+BEGIN_SRC emacs-lisp +n
(use-package auto-complete-config
  :ensure auto-complete
  :custom
  (ac-comphist-file (my-locate-user-tmp-file "ac-comphist.dat"))
  :config
  (ac-config-default)
  ;; メジャーモードに関する辞書
  (add-to-list 'ac-dictionary-directories
               (locate-user-emacs-file "ac-dict"))
  ;; (if (and (linuxp) (= emacs-major-version 23))
  ;;     nil
  ;;   (ac-config-default))
  ;; 23 でも大丈夫になったらしい 2011-06-04 (Sat)
  (setq ac-auto-show-menu 0.08)       ; 補完メニュー表示の遅延時間
  (setq ac-quick-help-delay 0.5)     ; help 表示の遅延時間
  (define-key my-original-map (kbd "TAB") 'auto-complete) ; あえて手動で補完したい時
  (setq ac-use-overriding-local-map t) ; ローカルマップの TAB を乗っ取る？
                                        ; おもに org-mode で使いたいので付けとく．
                                        ; 本来の org-mode の TAB がどれほど使えなくなるのかが心配
  (setq ac-candidate-menu-min 0) ; 候補が1つでも補完メニューを表示する
  (setq ac-disable-inline t) ; 候補が1つの場合のインライン補完を無効にする

  ;; auto-complete を有効にするモード
  (dolist (library '(matlab-mode matlab-shell-mode ruby-mode
                                magit-log-edit-mode eshell-mode))
    (add-to-list 'ac-modes library))
  ;; key bind
  (define-key ac-complete-mode-map (kbd "<C-tab>") 'yas/expand)
  (define-key ac-complete-mode-map (kbd "C-s") 'ac-isearch)
  (define-key ac-complete-mode-map (kbd "M-h") 'ac-quick-help)

  ;; 情報源のデフォルト値にyasnippet情報源を加える
  (cl-pushnew 'ac-source-yasnippet (default-value 'ac-sources))

  )

(my-measure-message-time "Non-standard elisp setting.")
#+END_SRC
** ispell.el
スペルチェック．
#+BEGIN_SRC emacs-lisp +n
;; コマンドの設定
(use-package ispell :defer t
  :config
  (setq ispell-program-name "aspell")
  (setq ispell-grep-command "grep") ; デフォルトの egrep が Cygwin ではシンボリックリンク
                                        ; なので，Meadow から起動できない
  (setq ispell-personal-dictionary "~/.aspell.en.pws") ; 個人用辞書
  (setq ispell-silently-savep t) ; 確認なしに辞書に保存する
  ;; 日本語ファイル中の英単語スペルチェックを可能にする
  (with-eval-after-load 'ispell
    (add-to-list 'ispell-skip-region-alist '("[^\000-\377]"))))
#+END_SRC
** migemo.el
- [[http://d.hatena.ne.jp/j-kyoda/20110316][emacs23(Windows)でcmigemoを使う - j-kyodaのつぶやき]]
ローマ字で日本語検索．Windows 用 dll ではなく，Cygwin でビルドすることにした．
#+BEGIN_SRC emacs-lisp +n
  (use-package migemo
    :if (executable-find "cmigemo")
    :init
    (defun migemo-dict-find ()
      "Find a migemo dictionary"
      (cl-loop for dict
               in (list
                   (expand-file-name "utf-8/migemo-dict" "/usr/local/cmigemo")
                   (expand-file-name "utf-8/migemo-dict" "/usr/local/share/migemo")
                   (expand-file-name "lib/cmigemo/bin/dict/utf-8/migemo-dict"
                                     (getenv "chocolateyinstall"))
                   (expand-file-name "dict/utf-8/migemo-dict"
                                     (file-name-directory (executable-find "cmigemo"))))
               when (file-readable-p dict)
               return dict))
    :custom
    (migemo-pattern-alist-file (my-locate-user-tmp-file "migemo-pattern"))
    (migemo-command "cmigemo")
    (migemo-options '("-q" "--emacs")); "-i" "\a"))
    (migemo-coding-system 'utf-8-unix)  ; 辞書の文字コードを指定
    (migemo-user-dictionary (expand-file-name "~/migemo/user-dict"))
    (migemo-regex-dictionary (expand-file-name "~/migemo/regex-dict"))
    ;; キャッシュ機能を利用する
    (migemo-use-pattern-alist t)
    (migemo-use-frequent-pattern-alist t)
    (migemo-pattern-alist-length 1024)
    :config
    ;; migemo-dict のパスを指定
    (setq migemo-dictionary (migemo-dict-find))
    ;; helmでmigemoを有効にする（helm-migemoは必要なくなった）
    (with-eval-after-load 'helm
      (helm-migemo-mode 1))
    ;; 起動時に初期化も行う
    (migemo-init))
#+END_SRC
** 測定終了
#+BEGIN_SRC emacs-lisp +n
(my-measure-message-time "Big elisp setting.")
#+END_SRC
* 内部的な設定を読み込む
#+BEGIN_SRC emacs-lisp +n
(let ((internal-file (locate-user-emacs-file "internal.el")))
  (when (file-exists-p internal-file)
    (load internal-file)))
#+END_SRC
